## 进程实体

数据段

代码段

PCB（进程控制块） -- OS为每个进程分配一个，描述进程的各种信息，如程序代码存放的位置









## 进程定义

进程是一个动态的概念，比较传统典型的定义有：

- 是程序的一次 **执行过程**
- 是程序及其数据在CPU上顺序执行时所 **发生的活动**
- 是程序在数据集合上 **运行的过程**，是资源分配和调度的独立单位

进程是进程实体的 **运行过程**

进程实体是静态的，进程是动态的









## 进程分类

根据功能可分为两大类

#### 系统进程

执行内存资源分配和进程切换等管理工作，不受用户干预，root用户也不例外



#### 用户进程

通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，可在用户的控制下运行或关闭

用户进程又可分为交互进程、批处理进程和守护进程

- 交互进程 -- shell终端启动的进程，需要与用户进行交互操作，可以运行于前后台
- 批处理进程 -- 是一个进程集合，负责按顺序启动其他进程
- 守护进程 -- 是一直运行的进程，随着系统启动而启动，在系统关闭时终止









## 进程的状态

- 运行状态 -- 进程正在CPU中执行，或者在运行队列（run queue）中等待运行
- 停止状态 -- 进程由于特定的信号（如SIGINT、SIGSTOP）而挂起就会处于这个状态，等待恢复信号，比如SINCONT
- 可中断的等待状态 -- 进程处于阻塞状态，一旦达到某种条件，就会变为运行态。同时该状态的进程也会由于接收到信号而被提前唤醒进入到运行态。
- 不中断的等待状态 -- 与可中断的等待状态”含义基本类似，唯一不同的是处于这个状态的进程对信号不做响应。不中断的等待状态最典型的例子是进程等待磁盘IO操作
- 僵死状态 -- 也就是僵死进程，每个进程在结束后都会处于僵死状态，等待父进程调用进而释放资源，处于该状态的进程已经结束，但是它的父进程还没有释放其系统资源









## 父子进程

#### 关系

父进程发起fork()系统调用，创建子进程，获得一个进程描述符，复制父进程的进程描述符给子进程

父进程管理子进程，子进程退出时，会发送信号告知父进程，之后父进程调用wait()系统调用，获取子进程状态（退出状态及其他信息），然后清除子进程所有数据结构和进程描述符，释放其系统资源，从内存中将其移除



#### 僵尸进程

从子进程终止，到父进程调用wait()系统调用这段时间，子进程处于僵尸进程状态

一般僵尸进程阶段很快就结束，当编程不合理等情况，父进程一直不调用wait()系统调用，就会使子进程一直处于僵尸进程状态



#### 孤儿进程

如果子进程退出前父进程已经退出了，子进程就成为孤儿进程，需重新指定其他进程作为他的父进程（可以指定超级父进程），释放其占用的资源



#### 超级父进程

PID=1进程是Linux的，所有进程都是他的后代









## 进程优先级

进程的优先级，是决定进程在CPU中执行顺序的数字。优先级越高的进程被处理器执行的机会越大

进程优先级由动态优先级和静态优先级决定，根据进程的行为，内核使用启发式算法决定开启或关闭动态优先级

可以通过nice级别直接修改进程的静态优先级，拥有越高静态优先级的进程会获得更长的时间片

Linux支持的nice级别从19 （最低优先级）到20 （最高优先级） ，默认为0，只有root身份的用户才能把进程的nice级别调整为负数（让其具备较高优先级）









## 进程控制

OS把进程指针按照的进程不同状态放入不同的队列

就绪队列/工作队列 -- CPU分时执行就绪队列中的进程

阻塞队列/等待队列 -- 根据不同的阻塞事件分为多个阻塞队列



#### 阻塞和唤醒

阻塞时，CPU会保护现场，把当前进程的上下文保存在PCB中，并把PCB中的标志位从运行态改为阻塞态，放进相应事件的等待队列中

唤醒时，在事件等待队列中找到PCB，将标志位从阻塞态改为就绪态，从等待队列移除，插入就绪队列

阻塞和唤醒要成对出现，因为什么事件阻塞，就会因为什么事件唤醒









## 进程调度

计时部件向CPU发送中断信号，告诉CPU当前时间片已用完

让OS介入，将CPU使用权交给OS

OS就处理中断信号

OS发现中断信号是时间片已用完的信号，就切换下一个线程执行

这就实现了CPU执行多个线程



#### 调度时机

- 程序主动放弃CPU

  进程自然终止

  程序异常

  主动申请中断阻塞（比如IO等待）

- 程序被动放弃CPU

  CPU时间片用完

  中断信号产生
  
  更高优先级的进程进入就绪队列
  
  







## 进程通信

- 共享空间 -- 通过共享空间来访问其他进程的空间，访问共享空间互斥，写的时候不能读

- 管道通信 -- 在内存中开辟的缓冲区，大小一般和内存页面一样（在Linux中就是4k）

  管道只能实现半双工通信，即一个时间段内只能单向传输，全双工需要两个管道，管道访问也互斥

  管道写满了才能读，读空了才能写

  只能有一个进程从管道读数据

- 消息传递









## 进程互斥

临界资源 -- 一个时间段内只允许一个进程使用的资源，比如摄像头、打印机、变量、数据、内存缓冲区



#### 进程互斥 

进程间必须互斥地使用临界资源

当进程A访问临界资源时，进程B想要访问该临界资源必须等待

等进程A对访问临界资源结束，释放资源之后，进程B才能访问临界资源

临界资源互斥访问分为四个部分

- 进入区

  上锁 -- 检查是否可进入临界区，设置**正在访问临界资源的标志**

- 临界区

  访问临界资源的指令

- 退出区

  解锁 -- 解除正在访问临界资源的标志

- 剩余区









## 进程与线程

#### 关系

- 一个线程只能属于一个进程，一个进程可以有多个线程，至少有一个线程
- 进程作为资源分配的最小单位，资源是分配给进程的，同一进程的所有线程共享该进程的所有资源
- 真正在处理机上运行的是线程



#### 区别

- 调度：线程是调度和分配的基本单位，进程是拥有资源的基本单位
- 并发性：进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
- 拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源
- 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，所以系统的开销明显大于创建或撤消线程时的开销









## 线程

#### 进程的弊端

传统的进程是程序执行流的最小单位，一个进程只能串行执行程序

并发调度时需要切换进程的运行环境，开销过大

所以引入线程，增加并发度



#### 线程的作用

线程可以理解为轻量级进程，是CPU调度的基本单位，是程序执行流的最小单位

每个进程包含多个线程，CPU通过调度算法轮流服务线程

线程切换不需要切换进程环境，开销变小









## 信号量

信号量就是一个变量，表示系统中某种资源的数量

#### 一对原语

可以使用一对原语：wait原语和signal原语操作信号量

wait（P）原语相当于进入区，占用临界资源

signal（V）原语相当于退出区，释放临界资源

PV必须**成对出现**



#### 信号量类型及工作原理

信号量有两种：

- 整形信号量

  用一个整形变量作为信号量，表示资源数

  进程会死循环判断信号量，决定是否进入临界区

  若系统资源暂时不够，即进程进不了临界区，会导致CPU空转，一直死循环判断，不满足“让权等待”

- 记录型信号量

  用一个记录型数据结构表示信号量，结构：

  > 剩余资源数value
  >
  > 等待队列

  执行**wait原语**时将value减1，若value<0，表示资源数不够，使用**block原语**阻塞当前进程（主动放弃CPU，不会忙等，浪费CPU资源，做到“让权等待”），添加进等待队列

  进程用完资源执行**signal原语**时，会将value+1，若value<0，会使用**wakeup原语**唤醒等待队列中的一个进程，将其放入就绪队列

<img src=".\pic\临界资源访问.jpg" style="zoom:80%; float:left" />



#### 信号量实现互斥

划定临界区

设置互斥信号量mutex，初值1

在临界区之前对信号量执行P(mutex)操作

在临界区之后对信号量执行V(mutex)操作





 12.进程和线程的关系和区别 

 13.进程和线程共享了资源,线程也自己独有一些资源,那么具体哪些资源是共享的,哪些资源 

 是线程独有的 

2.3.4