## 进程实体

数据段

代码段

PCB（进程控制块） -- OS为每个进程分配一个，描述进程的各种信息，如程序代码存放的位置









## 进程定义

进程是一个动态的概念，比较传统典型的定义有：

- 是程序的一次 **执行过程**
- 是程序及其数据在CPU上顺序执行时所 **发生的活动**
- 是程序在数据集合上 **运行的过程**，是资源分配和调度的独立单位

进程是进程实体的 **运行过程**

进程实体是静态的，进程是动态的









## 进程分类

根据功能可分为两大类

#### 系统进程

执行内存资源分配和进程切换等管理工作，不受用户干预，root用户也不例外



#### 用户进程

通过执行用户程序、应用程序或内核之外的系统程序而产生的进程，可在用户的控制下运行或关闭

用户进程又可分为交互进程、批处理进程和守护进程

- 交互进程 -- shell终端启动的进程，需要与用户进行交互操作，可以运行于前后台
- 批处理进程 -- 是一个进程集合，负责按顺序启动其他进程
- 守护进程 -- 是一直运行的进程，随着系统启动而启动，在系统关闭时终止











## 进程控制

OS把进程指针按照的进程不同状态放入不同的队列

就绪队列/工作队列 -- CPU分时执行就绪队列中的进程

阻塞队列/等待队列 -- 根据不同的阻塞事件分为多个阻塞队列



#### 阻塞和唤醒

阻塞时，CPU会保护现场，把当前进程的上下文保存在PCB中，并把PCB中的标志位从运行态改为阻塞态，放进相应事件的等待队列中

唤醒时，在事件等待队列中找到PCB，将标志位从阻塞态改为就绪态，从等待队列移除，插入就绪队列

阻塞和唤醒要成对出现，因为什么事件阻塞，就会因为什么事件唤醒









## 进程调度

计时部件向CPU发送中断信号，告诉CPU当前时间片已用完

让OS介入，将CPU使用权交给OS

OS就处理中断信号

OS发现中断信号是时间片已用完的信号，就切换下一个线程执行

这就实现了CPU执行多个线程



#### 调度时机

- 程序主动放弃CPU

  进程自然终止

  程序异常

  主动申请中断阻塞（比如IO等待）

- 程序被动放弃CPU

  CPU时间片用完

  中断信号产生
  
  更高优先级的进程进入就绪队列
  
  







## 进程通信

- 共享空间 -- 通过共享空间来访问其他进程的空间，访问共享空间互斥，写的时候不能读

- 管道通信 -- 在内存中开辟的缓冲区，大小一般和内存页面一样（在Linux中就是4k）

  管道只能实现半双工通信，即一个时间段内只能单向传输，全双工需要两个管道，管道访问也互斥

  管道写满了才能读，读空了才能写

  只能有一个进程从管道读数据

- 消息传递









## 进程互斥

临界资源 -- 一个时间段内只允许一个进程使用的资源，比如摄像头、打印机、变量、数据、内存缓冲区



#### 进程互斥 

进程间必须互斥地使用临界资源

当进程A访问临界资源时，进程B想要访问该临界资源必须等待

等进程A对访问临界资源结束，释放资源之后，进程B才能访问临界资源

临界资源互斥访问分为四个部分

- 进入区

  上锁 -- 检查是否可进入临界区，设置**正在访问临界资源的标志**

- 临界区

  访问临界资源的指令

- 退出区

  解锁 -- 解除正在访问临界资源的标志

- 剩余区









## 线程

#### 进程的弊端

传统的进程是程序执行流的最小单位，一个进程只能串行执行程序

并发调度时需要切换进程的运行环境，开销过大

所以引入线程，增加并发度



#### 线程的作用

线程可以理解为轻量级进程，是CPU调度的基本单位，是程序执行流的最小单位

每个进程包含多个线程，CPU通过调度算法轮流服务线程

线程切换不需要切换进程环境，开销变小









## 信号量

信号量就是一个变量，表示系统中某种资源的数量

#### 一对原语

可以使用一对原语：wait原语和signal原语操作信号量

wait（P）原语相当于进入区，占用临界资源

signal（V）原语相当于退出区，释放临界资源

PV必须**成对出现**



#### 信号量类型及工作原理

信号量有两种：

- 整形信号量

  用一个整形变量作为信号量，表示资源数

  进程会死循环判断信号量，决定是否进入临界区

  若系统资源暂时不够，即进程进不了临界区，会导致CPU空转，一直死循环判断，不满足“让权等待”

- 记录型信号量

  用一个记录型数据结构表示信号量，结构：

  > 剩余资源数value
  >
  > 等待队列

  执行**wait原语**时将value减1，若value<0，表示资源数不够，使用**block原语**阻塞当前进程（主动放弃CPU，不会忙等，浪费CPU资源，做到“让权等待”），添加进等待队列

  进程用完资源执行**signal原语**时，会将value+1，若value<0，会使用**wakeup原语**唤醒等待队列中的一个进程，将其放入就绪队列

<img src=".\pic\临界资源访问.jpg" style="zoom:80%; float:left" />



#### 信号量实现互斥

划定临界区

设置互斥信号量mutex，初值1

在临界区之前对信号量执行P(mutex)操作

在临界区之后对信号量执行V(mutex)操作





 12.进程和线程的关系和区别 

 13.进程和线程共享了资源,线程也自己独有一些资源,那么具体哪些资源是共享的,哪些资源 

 是线程独有的 

2.3.4