#### Redis二进制安全

外面客户端啥编码，Redis不知道，客户端要把value转成字节数组给Redis，Redis是二进制安全的，只保存二进制，不管编码，所以客户端使用Redis时一定要约定好编解码规则

- Redis单线程的意义

  Redis单线程保证原子操作，数据一致性，线程安全

  若Redis多线程操作，就得用锁去保证上述问题

- MySQL更倾向使用BIO，一个请求一个线程，需要更多的线程

  如果进来很多个请求，每个请求都触发磁盘IO，磁盘IO带宽会打满，阻塞住。这时看起来好像很多请求进来了，但都得阻塞住，故这里用Epoll意义不大，直接用BIO

- Redis快且并发高的原因之一：

  Redis会有核心亲密度的概念，将Redis亲密到某个core上，即Redis进程只跑在一个core上，不用别的core跑，即让其他进程用别的core，不用Redis的这个core跑，不切换时间片，也使这个core的三级缓存不用频繁清理

- bitmap用途

  统计任意时间区间内用户的登录情况，用户id做key，bit代表每年的每天

  统计日活跃用户数，日期做key，用户id做bit

  可用来数字排序 https://www.jianshu.com/p/bf9dbbc147ed
  
  可用来统计用户是否在线、签到，用年份+用户id做key
  
  bitmap操作统计日活的命令复习下（bitset、bitget、bittop、bitcount）  03-7



#### Redis数据类型

- 阻塞列表

  BLPOP，可实现阻塞队列，获取不到元素就一直阻塞着直到有元素

- zset
  `学一下`

  - zset用跳表实现

  - 跳表结构：

  - 跳表查询：

  - 跳表插入：查询到合适的位置并插入，然后调整指针

    若插入的元素要随机造层`即要不要对该节点多往上放几层是随机的，不懂准不准确，详细了解下`，则找到左边最近的且有多层的节点，找到他上面第二层，然后插入，调整指针。然后继续找到第二层左边节点的上面一层，在上面那层插入自己，调整指针，以此类推，直到顶层

  - 跳表更新：先把自己删了，再走一遍插入的过程

  - 当一个有序集合的元素数量比较多或者成员是比较长的字符串时，会转换为跳表存储，跳表的层数根据数据量来定

  - 跳表是一种**类平衡树**（左旋右旋调整高度），并不是在增删改查某一方面效率最高，而是在并发高的时候各种操作的**平均效率**最高、最稳定

  - 应用场景

    微信近三天聊天记录，score为时间点，元素为聊天内容



#### Redis管道



#### Redis发布订阅

类似于一个队列，FIFO，所有连接到发布订阅集合的客户端都可以从里面读取最新数据，比如在线课堂聊天窗口场景



#### Redis事务

MULTI命令：开启事务

EXEC命令：执行事务

WATCH命令：如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断

开启事务到执行事务之间的所有命令会被放进队列中，当执行EXEC命令时会按顺序原子性地执行队列中的命令，若事务中任意命令执行失败，其余的命令依然被执行，没有回滚操作

线程一：MULTI                  -> GET k1                 -> EXEC

线程二：                 MULTI -> DEL k1   -> EXEC

以上情况，线程一虽然先开启事务，但由于线程二比他先执行事务了，所以GET k1时就取不到了

[Redis事务应用场景](https://blog.csdn.net/weixin_30585437/article/details/97959479)

epoll模型、数据类型、持久化、三种架构模式、雪崩击穿穿透、分布式锁、lua、lru



#### 布隆过滤器

可到Redis英文官网的module下载bloom模块

一个元素判断结果为存在时它不一定存在，判断结果为不存在时一定不存在

根据性能的考量，有多种架构方案：

- 客户端实现bloom算法+承载bitmap；Redis只做缓存
- 客户端实现bloom算法；Redis承载bitmap
- 客户端不做操作；Redis实现bloom算法+承载bitmap

[布隆过滤器](https://developer.aliyun.com/article/773205)

