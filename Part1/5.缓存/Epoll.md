- mmap：用户内核态共享空间，调用内核的mmap系统调用

  共享空间可视为进程私有空间的一部分，用红黑树保存数据

- epoll是一种系统调用：同步非阻塞多路复用
- Windows有AIO，Linux没有AIO
- 发送本地文件的过程（两次拷贝）
  - 第一次：磁盘文件加载到内核，对应fd3，调用内核read函数将文件读到应用程序中
  - 第二次：应用程序调用write函数将文件写回去内核，内核再通过网卡对应的fd4发送文件

- 零拷贝



#### Redis二进制安全

外面客户端啥编码，Redis不知道，客户端要把value转成字节数组给Redis，Redis是二进制安全的，只保存二进制，不管编码，所以客户端使用Redis时一定要约定好编解码规则

- Redis单线程的意义

  Redis单线程保证原子操作，数据一致性，线程安全

  若Redis多线程操作，就得用锁去保证上述问题

- MySQL更倾向使用BIO，一个请求一个线程，需要更多的线程

  如果进来很多个请求，每个请求都触发磁盘IO，磁盘IO带宽会打满，阻塞住。这时看起来好像很多请求进来了，但都得阻塞住，故这里用Epoll意义不大，直接用BIO

- Redis快且并发高的原因之一：

  Redis会有核心亲密度的概念，将Redis亲密到某个core上，即Redis进程只跑在一个core上，不用别的core跑，即让其他进程用别的core，不用Redis的这个core跑，不切换时间片，也使这个core的三级缓存不用频繁清理

- bitmap用途

  统计任意时间区间内用户的登录情况，用户id做key，bit代表每年的每天

  统计日活跃用户数，日期做key，用户id做bit

  bitmap操作统计日活的命令复习下（bittop、bitcount）  03-7



#### Redis数据类型

- 阻塞列表

  BLPOP，可实现阻塞队列，获取不到元素就一直阻塞着直到有元素

- zset
  `学一下`

  - zset用跳表实现

  - 跳表结构：

  - 跳表查询：

  - 跳表插入：查询到合适的位置并插入，然后调整指针

    若插入的元素要随机造层`即要不要对该节点多往上放几层是随机的，不懂准不准确，详细了解下`，则找到左边最近的且有多层的节点，找到他上面第二层，然后插入，调整指针。然后继续找到第二层左边节点的上面一层，在上面那层插入自己，调整指针，以此类推，直到顶层

  - 跳表更新：先把自己删了，再走一遍插入的过程

  - 当一个有序集合的元素数量比较多或者成员是比较长的字符串时，会转换为跳表存储，跳表的层数根据数据量来定
  - 跳表是一种**类平衡树**（左旋右旋调整高度），并不是在增删改查某一方面效率最高，而是在并发高的时候各种操作的**平均效率**最高、最稳定

看到04-5