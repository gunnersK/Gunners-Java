## 缓存与DB读写模式

#### Cache-Aside Pattern

- 双写读数据流程

  <img src=".\pic\双写读数据流程.jpg" style="zoom:80%; float:left" />



- 双写更新数据流程

  <img src=".\pic\双写更新数据流程.jpg" style="zoom:80%; float:left" />









## 缓存和DB双写不一致

<img src=".\pic\\双写不一致时序图.jpg" style="zoom:80%; float:left" />



- 先删缓存，再更新DB，再写缓存，高并发会出问题
- 将读写请求都路由到JVM的内存队列中
- 可对内存队列汇总的读请求进行去重，防止多次从DB查出来然后更新缓存

该方案存在的问题：

- 读请求长时阻塞：若写请求执行过慢，导致后面积压过多的读请求，读请求长时间阻塞，可以给读请求设置过期时间，过期前一直读缓存，过期了都读不到就直接查DB `读请求在内存队列中排在写请求后面，当写请求没执行完，那怎么对他后面的读请求进行这些操作呢，这里不理解`

  `读请求需要直接返回数据的，放内存队列不就异步了吗还怎么返回数据？`

- 读请求并发量过高：要严格测算出一个写请求会导致多少读请求hang住，估算出写读请求比例，最多不能超过1 : 3

- 多服务实例部署的请求路由：读写请求都路由到同一个机器上的同一个内存队列，不然还是有问题

  这么干又会导致热点数据的路由请求倾斜，在读写请求特别高时全部打到一台机器的相同队里去

  如果更新频率不大，这个问题影响也并不大

**详细在ryredis34**







## 缓存雪崩

#### 过程

多级缓存架构下

Redis集群挂了，导致缓存服务大量的请求hang在等待访问Redis集群上，资源被耗尽

缓存服务把请求全部转到业务系统去访问DB，导致DB被高并发打死，业务系统也hang住大量的请求等待DB响应，资源被耗尽，服务不可用

缓存服务的请求也hang在等待业务系统的响应，资源被耗尽，缓存服务不可用

导致Nginx本地缓存过期之后无法从缓存服务和业务系统获取数据，整个系统对外不可用



#### 事前

主从 + 双机房部署

#### 事中

做好缓存服务对Redis访问的资源隔离熔断降级（可以做熔断半开策略，自动恢复），保持缓存服务不要挂，还可以从缓存服务的本地缓存（ehcache）中获取一部分数据

也要做好对业务系统的隔离熔断降级

#### 事后

重启Redis，从备份的持久化文件恢复数据

若Redis数据彻底丢失或数据过旧，就先不要启动业务系统，给Redis做个缓存预热，把最新最热的数据放进去再重启