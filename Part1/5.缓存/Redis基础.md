https://www.cnblogs.com/mrhgw/p/6278619.html

https://blog.csdn.net/hellozpc/article/details/81267030

https://www.jianshu.com/p/7bf5dc61ca06/ （如何使用RedisTemplate访问Redis数据结构）

# 安装启动

- 启动服务：在bin目录下，./redis-cli redis.conf

- 关闭服务：在bin目录下，./redis-cli shutdown

- 执行 ./redis-cli进入自带客户端工具

#  数据类型及命令

   1. 操作key的命令：del
   
   1. String
      
      1. 命令
      
         1. set,get,decr,incr,mget（返回所有给定 key 的值）
         
         2. setnx 
         
            1. 作用：在指定的key不存在时，为key设置指定的值，实现分布式锁，当key不存在，则设置成功，当key存在，即尝试覆盖key，则设置失败
            
            2. setnx key value
            
            3. 返回值：设置成功返回1，失败返回0
   
   2. Hash：Hash实际是内部存储的Value为一个HashMap，也就是说，value是一个Map，这个Map的key，也称为field（redis称内部Map的key为field），是成员属性名，value是属性值
      
      1. 命令
         
         1. hset key field value
            
            1. 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作

            2. 如果字段已经存在于哈希表中，旧值将被覆盖
            
            3. 返回值：成功设值返回1，旧值被覆盖返回0
            
         2. hdel key field1 field2....
            
            1. 作用：删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略
            
            2. 返回值：被成功删除字段的数量，不包括被忽略的字段
            
         3. hgetall key
            
            1. 返回值：以列表形式返回哈希表的字段及字段值，若 key 不存在，返回空列表
            
         4. hexists key field
         
            1. 作用：用于查看哈希表的指定字段是否存在
   
   3. List：双向链表，可以添加一个元素到列表的头部（左边）或者尾部（右边）
      
      1. 命令
         
         1. lpush/rpush key value1 value2....
            
            1. 作用：将一个或多个值插入到key对应的列表头部/尾部
            
            2. 如果key不存在，则会创建一个空列表
            
            3. 如果key存在但不是列表类型时，返回一个错误
            
            4. 返回值：列表的长度
            
         2. lpop/rpop key 
         
            1. 作用：移除并返回列表的第一个/最后一个元素
            
            2. 返回值：移除的元素，当列表不存在，返回nil
            
         3. lrange key start stop

            1. 作用：返回列表中指定区间内的元素
            
            2. 规则：下标start和stop都已0为底，0表示第一个成员，1表示第二个成员，-1表示最后一个成员，-2表示倒数第二个成员，以此类推
            
            3. 返回值：包含指定区间内的元素的一个列表
            
         4. lindex key index
         
            1. 作用：通过索引获取列表中的元素，可用负数表示下标
   
   4. Set：类似List，可自动排去重，是一个value永远为null的hashmap，可以进行求交集、并集、差集等操作
      
      1. 命令
         
         1. sadd key value1 value2....
            
            1. 作用：将一个或多个成员元素加入到集合中，已经存在于集合的成员元素将被忽略
            
            2. 返回值：被成功添加到集合中的新元素的数
            
         2. spop key [count]
            
            1. 作用：移除指定 key 的集合中的一个或多个随机元素
            
            2. count 参数在 3.2+ 版本可用，定义移除元素的个数
            
            3. 返回值：返回移除的元素
            
         3. smembers key
            
            1. 作用：返回集合中的所有的成员，不存在的集合 key 被视为空集合
            
         4. sunion key1 key2....
            
            1. 作用：返回给定集合的并集
            
         5. sismember key value
         
            1. 作用：判断成员元素是否是集合的成员
   
   5. Sorted Set：可以通过用户提供的一个优先级（score）参数来为成员排序，并且是插入有序，即自动排序，是一个**有序且不重复**的集合列表
      
      1. 命令
         
         1. zadd key score1 value1 score2 value2....
            
            1. 作用：将一个或多个成员元素及其分数值加入到有序set当中
            
            2. 如果某个成员已经是有序set的成员，那么更新这个成员的分数值，并根据分数值对这个成员重新排序
            
            3. 注意：在2.4之前，每次只能添加一个元素
            
            4. 返回值：被成功添加的新成员的数量，不包括被更新的，即已存在的成员
            
         2. zrange key start stop [withscores]
            
            1. 作用：返回有序集中，指定区间内的成员
            
            2. 规则：下标start和stop都已0为底，0表示第一个成员，1表示第二个成员，-1表示最后一个成员，-2表示倒数第二个成员，以此类推
            
            3. 返回值：指定区间内带有分数值（可选）的有序set成员列表，如果命令后面有带上withscores则显示score值
            
         3. zrem key member1 member2....
            
            1. 作用：移除有序set中的一个或多个成员，不存在的成员将被忽略
            
            2. 返回值：被成功移除的成员的数量，不包括被忽略的成员
           
         4. zcard key 
            
            1. 作用：计算集合中元素的数量
            
            2. 当key存在，且是有序set类型时，返回元素数量，否则返回0
   
   6. expire命令：
      
      1. 设置key的过期时间，单位以秒计
      
      2. expire key seconds
      
   7. del命令
   
      1. 删除key
      
      2. del key
      
   8. exists命令
      
      1. 检查key是否存在，存在返回1，不存在返回0
      
      2. exists key
      
   9. ltrim 命令
      
      1. 只保留指定区间之内的元素，删除区间之外的元素，从0开始，可用负数下标
      
      2. ltrim key start stop

   10. keys命令

            1. 模糊查询所有匹配的key -> https://www.cnblogs.com/sharesdk/p/9203449.html

   11. 关于key，有几个要注意

            1. key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率
            
            2. key也不要太短，太短的话，key的可读性会降低
            
            3. 在一个项目中，key最好使用统一的命名模式，例如user:10000:passwd 

# 分布式锁

- redisson就是个redis的客户端，类比jedis

- 分布式系统中运行着多个节点，必须确保在同一时刻只能有一个节点的一个线程获得锁，这是最基本的一点。

- 死锁：分布式锁有必要设置时效，确保在未来的一定时间内，无论获得锁的节点发生了什么问题，最终锁都能被释放掉。

- 设计分布式锁时要能够掌握锁持有者的动态，若判断锁持有者处于不活动状态，要能够强制释放其持有的锁。

- 排队等待锁的节点如果不知道锁何时会被释放，则只能隔一段时间尝试获取一次锁，这样无法保证资源的高效利用，因此当锁释放时，要能够通知等待队列，使一个等待节点能够立刻获得锁。

- 理论知识

   - https://www.jianshu.com/p/a1ebab8ce78a
   
   - 含义：在分布式系统中，假如有三个jvm节点共同操作一个变量，这时就需要用**分布式锁**来保证线程安全，防止线程间相互干扰
   
   - 实现
   
      - 分布式锁实现的三个核心要素：
      
         - 加锁：比如要给一种商品的秒杀活动加锁，可以给key命名为goodId，value假设为1，利用setnx命令来实现
      
         - 解锁：使用del命令删除key
         
         - 锁超时：一个节点在进行的过程中挂了，来不及显式地释放锁，这块资源将会被永远锁住，形成**死锁**，可以在使用setnx的基础上再使用expire命令解决问题
         
      - 举例
      
         - 看看伪码

				```
					if(setnx(goodId, 1) == 1){
                  expire(goodId, 30);
                  try{
                     do somethings....
                  } finally{
                     del(goodId);
                  }
               }
				```
			
         - 分析：这种实现方法存在两个问题
           
            - 死锁：因为setnx和expire两个操作合起来不是原子性的，所以如果某个线程刚执行完setnx还没来得及执行expire就挂了，那么这把锁将没有被设置过期时间，形成死锁

            - 删错：如果线程a执行的很慢，锁到期都没执行完，这时线程b得到这把锁，然后线程a执行完了，执行del来释放锁，但这时这把锁是线程b持有的，所以他**实际上释放的是线程b的锁**
            
         - 解决办法：
         
            - 第一个问题可以针对setnx和expire操作非原子性来做文章，最好把他们合为一条语句，redis中setnx本身不支持传入超时时间的，但是set命令增加了相关参数，**现在我也搞不清楚....反正set命令还有这么一个功能就是了，先记着吧，以后再解决**
            
            - 第二个问题可以在del释放锁之前加一个判断，验证当前的锁是不是自己加的锁，实现：可以在加锁的时候把自己线程id当作value，del之前验证key对应的value是不是自己的id，但是这样判断和释放又不是原子性了，又存在线程不安全的问题
            
            - 完美解决方法：给获得锁的线程开启一个**守护线程**，给快要过期但所在线程还没执行完的锁续航，设置这个守护线程当过去了29秒之后线程还没执行完，就给这个锁续命20秒，然后每20秒执行一次，当线程执行完，显式关掉守护线程
            
               - 当线程执行一半就挂了，因为守护线程和他在同一个进程，所以守护线程也会停下，当锁超时（set的时候已经设置超时时间了），没有守护线程给他续命，就会自动释放，也就不会发生死锁
            
               - 因为当线程没执行完时，守护线程会一直给锁续命，所以也就杜绝了释放错锁错误
   
# 其他
1. redis为什么要序列化？
   
   1. 在java中，一切都是对象，凡是需要进行跨平台传输和网络传输的对象数据，都需要进行序列化

   2. 下列方法可以序列化对象，同时可读性又强
      
      1. GenericToStringSerializer: 可以将任何对象泛化为字符串并序列化

      2. Jackson2JsonRedisSerializer: 跟JacksonJsonRedisSerializer实际上是一样的
      
      3. JacksonJsonRedisSerializer: 序列化object对象为json字符串

      4. JdkSerializationRedisSerializer: 序列化java对象

      5. StringRedisSerializer: 简单的字符串序列化   

#  进阶

- jedis：java语言的redis客户端

- redisson：另一种redis客户端，可实现分布式锁

- codis：一种redis的代理，客户端连接codis和直接连接redis区别不大

- redis三种模式：单机模式、主从模式、哨兵模式
