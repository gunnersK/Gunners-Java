## TCP/IP

TCP监控：`tcpdump -nn -i eth0 端口号`，用来抓取数据包

当服务端程序启动，`netstat -natp` 可看到：服务端会开启LISTEN状态申请端口号，监听端口号

然后`lsof -p pid` 查看进程文件描述符的分配情况



#### TCP连接

TCP协议是面向连接的，走完三次握手，双方就会有资源的开辟，尽管服务端程序阻塞住无法接收客户端发的包，客户端内核也会开辟资源进行接收和等待

双方通过三次握手开辟资源，可为对方提供服务，连接就建立了，连接不是物理的，看不见摸不着，是靠资源来代表的

看到001800，下一步回到开头把文件抄下来放linux跑



任何IO模型，上层应用和内核之间有固定的三步：

- 系统调用返回socket文件描述符
- 绑定端口
- 监听文件描述符

accept，从FD等待客户端连接，进入阻塞状态

recv，从FD读取客户端传来的信息，进入阻塞状态

#### BIO式

主线程死循环接收accept，随后克隆多个线程，来一个连接起一个线程，每个的线程做读取操作，recv

内核while死循环监听，连接进来，进行accept系统调用，随后fork线程，每次都创建线程，所以速度慢

无论哪种IO模型，都必须三次握手

BIO的弊端：阻塞(blocking)，accept阻塞，读取也阻塞































linux为什么慢看到0006