- hash算法、寻址算法的优化

- 如何解决hash冲突

- 扩容、rehash过程，rehash算法优化

 

## 构造方法

若new时指定容量值，会自动使用他最接近的2的整数次幂值去初始化容量

思考：能否用链表代替数组实现？可以，但是用数组效率查找比链表高。put操作时可以用hash值对数组长度取模直接定位到插入位置

思考：ArrayList底层也是数组，为何不用他？因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高







## hash算法

#### 计算hash

```java
// jdk源码
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

把hashCode二进制右移（>>>）16位，再与原值进行异或运算

> 异或运算：相同得0，相反得1
>
> 位移运算符：
>
> ```<<``` 乘2
>
> ```>>``` 除2
>
> ```>>>```无符号右移，空位0补齐



#### 寻址算法

把hash值跟数组长度 - 1再进行与运算（&），即：```(n - 1) & hash```，得到数组下标

这样做性能比直接%取模性能高，减少哈希碰撞



**没有解为何移16位再异或和（n-1）&运算为何会减少哈希碰撞**







## hash碰撞

当hash碰撞时会在元素后面挂链表，若链表长度大于8，将链表转换为红黑树

遍历链表的时间复杂度为O(n)，红黑树查找时间复杂度为O(logn)

思考：为什么链表长度大于8会转换红黑树？为什么是红黑树？可以用别的树吗？红黑树，查询性能提升了多少？修改性能提升了没？ 

 红黑树是平衡二叉树吗？左旋右旋的时间复杂度？





## 扩容

当数组大小超过0.75倍容量时会扩容为2的n次方

为什么是2的n次方？为了寻址时用能用hash&(n - 1)，提高运算效率，减少哈希碰撞





> HashMap面试必问的6个点，你知道几个？https://juejin.cn/post/6844903921190699022