## 前置知识

#### 全表扫描

一个个数据页加载进BP，然后一行行扫，扫完一页扫下一页，直到查找成功



#### 页目录

每个数据页都有一个页目录

页目录中每条记录保存了主键+槽位

槽位是由连续的数据行组成的

类似于**跳表**的结构

页目录的结构：List<页目录记录>

页目录记录的结构：Map<主键, List<数据行>>

主键查找：根据主键二分查找到槽位

<img src=".\pic\数据页目录.jpg" style="zoom: 80%; float: left" />



#### 数据页有序

后一个数据页的主键值都大于前一个数据页的主键值，保持数据行有序，方便建索引



#### 页分裂

当装满一个数据页，开辟第二个数据页时

若主键是自己设置，且非递增，且新增到第二页的记录的主键值小于前一页的主键值

MySQL会将数据行进行挪动，保证下一个数据页的主键值都大于上一个数据页的主键值

这就是页分裂







## 聚簇索引

#### 主键目录

把每个数据页的页号，还有数据页里最小的主键值放在一起，组成一个索引的目录

根据主键值到主键目录二分查找，找到对应数据页，加载到BP中，再根据页目录对主键进行二分查找定位到某一行



#### 索引页

和数据页类似，索引页中保存了一行行数据，或称为键值

聚簇索引会将多个索引页组织为一棵 **B+ 树**，叶子结点就是数据页

最下层的索引页（叶子结点的上一层）中，每行数据保存**下层数据页中的最小主键值，和下层数据页的引用**

其他索引页则保存了**下层索引页中的最小主键值，和下层索引页的引用**

`插入数据时索引B+树的变化再理解下69`

数据页、索引页之间双向链表相连；数据页、索引页内部的数据行之间单向链表相连 `这么做是方便范围查询？`

B+ 树的阶数（即一个节点最多能有几个子节点）等于键值（即数据行）的数量，如果 B+ 树一个节点存储 1000 个键值，那 3 层 B+ 树可以存储 1000×1000×1000=10 亿个数据

一般根索引页节点是常驻内存的，所以一般查找 10 亿数据，只需要 2 次磁盘 IO

索引页和数据页共同组成 B+ 树，如果这棵 B+ 树的叶子结点就是数据页本身，那这棵B+树索引就是**聚簇索引**。若主键自增，会默认基于他做一个聚簇索引

<img src=".\pic\InnoDB聚簇索引结构.jpg" style="zoom: 80%;" />

#### 为什么索引不选择其他平衡树？

平衡二叉树、红黑树等平衡树，有一个旋转的过程，旋转时需要整棵树加载到内存来处理

在数据量大时内存会不够用，所以只能放磁盘

且又因为阶数低，只有2（两个树杈），所以高度较高，需要进行多次磁盘IO，导致数据在内存比较的时间远超磁盘IO时间



#### 为什么索引使用B+树而不是B树？

为了最大限度**减少磁盘IO**

B树所有节点都存储数据，而B+树只有叶子结点存储数据，非叶子结点存储键值

这就使得B+树每个非叶子结点可以存储更多的键值，相应树的阶数，即每个节点的子节点会更多，整个树会更矮更胖，查找时所需磁盘IO会更少，效率更高

每一层只需要通过二分查找即可快速定位到下一层数据页/索引页在磁盘中的位置

B+ 树使得范围查找，排序查找，分组查找以及去重查找变得很简单

而因为 B 树的数据分散在各个节点，较难实现这点



#### 各种树特点

二叉搜索树：不平衡，极端情况退化为链表

平衡二叉树、红黑树：磁盘IO过多，适合基于内存操作

B树：数据太分散，高度较高，磁盘IO多

B+树：只有叶子结点存储数据，高度更低，磁盘IO少







## 二级索引

即非主键索引

重新建一棵独立的 B+ 树来保存数据，叶子结点也是数据页

但是数据页只保存了主键和二级索引定义的字段数据，排序规则跟主键索引相同

找到后需要根据主键到聚簇索引进行**回表查询**其他二级索引中没有的字段







## 联合索引

重新建一棵独立的B+树来保存数据

每个数据页把联合索引所有字段的值和主键值作为一条记录

记录之间按所有字段的值来排序，先按第一个字段排，第一个字段相同按第二个字段排，以此类推

记录之间有序，数据页之间也有序

和聚簇索引一样，索引页则保存了**数据页/下层索引页中最小记录值，以及数据页/下层索引页的引用**

记录之间组织为单向链表，索引页、数据页之间组织为双向链表

![](.\pic\InnoDB联合索引结构.jpg)







## 基本索引使用规则

现有一个联合索引（class, student, subject）

- 最左列等值匹配

  根据最左侧连续多个字段做等值查找

- 最左列前缀匹配

  对最左列索引class列做LIKE 'abc%' 走索引，'LIKE '%abc' 不走索引

- 范围查找

  对最左列索引class列做大于、小于、between查询可以走索引

- 最左列等值匹配 + 范围匹配

  对最左列索引class列等值查找，同时对student范围查找，可以走索引，若subject也范围查找，subject就不走索引







## 排序使用索引

- 走索引

  按照联合索引的字段顺序进行order by，可直接利用B+树中的数据有序性排好序，然后获取数据的主键到聚簇索引进行回表查询获取剩余的字段

  某些情况下没有从索引最左字段开始排序也可以用到索引

- 不走索引

  每个字段的排序规则必须相同，即都是ASC或DESC，否则不走索引

  order by中有非索引字段，也不走索引







## 分组使用索引

与排序类似，最好是按照联合索引最左侧字段开始，按顺序排列来进行group by

`索引不适合建太多，会带来锁等待和死锁的问题，以及涉及到MySQL连接池、写redo log之类的问题，这块没搞懂`







## 回表查询及覆盖索引

如果查询走联合索引，但是select的字段有不在联合索引中的，这时就需要从联合索引中取出数据，然后每条数据都会到聚簇索引中查找，降低性能，称为**回表查询**

若是select *，字段太多，MySQL甚至有可能不走联合索引，直接走聚簇索引全表扫描

所以当需要回表查询时，尽量用limit限制查询记录数，这样回聚簇索引查找时只会查找limit次，就还是会走联合索引的

**覆盖索引**是当select的字段跟联合索引一一符合，可以直接就从联合索引中取出数据，不需要回表查询

`1.blob和text类型可以加索引吗？2.为什么索引的长度一般设计为2的幂次方？`







## 索引设计原则

- 索引避免包含散列度低的字段
- 较长字符串类型的列，设计前缀索引，即包含前面部分字符到索引中去，这时where走索引，order by和group by不走

- where字段带函数的不走索引
- 主键尽量自增，保持有序，自然的新增数据页，不会导致频繁页分裂，较耗时







## 索引实战

- where和order by大部分情况下没法同时用索引

- **只有第一个字段的范围查询用到索引，他后面的字段就都用不了索引了**

  所以要把经常做范围查询的字段放在最后一个

- in不算范围查询，因为搜索的值是确定的枚举值，属于等值匹配，可将频繁使用的包含枚举值范围的字段加进索引 

  如果where的字段在索引中，但由于索引中某些字段不用查询，不符合最左列等值匹配原则，可以考虑把这些字段用in(枚举值....)，来匹配最左查询原则，用上索引

  例如

  ```sql
  有联合索引
  (province, city, sex, age)
  有where语句
  where province='xx' and city='xx' and age > xx
  则可以优化为
  where province='xx' and city='xx' and sex in (0, 1) and age > xx
  使全部字段走索引
  ```

- 对于基数小，散列度低的字段，特殊情况下，可给他建立辅助索引，比如需要在他的基础上对其他字段排序

  例如sex字段

  ```sql
  有联合索引
  (sex, score)
  有sql
  select xx from table where sex=1 order by score limit xx, xx
  这里order by虽然没有从索引最左字段开始，但也可以用到索引排序
  ```

  