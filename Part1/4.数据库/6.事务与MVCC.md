#### 脏写、脏读

事务B去更新、查询没提交的事务A更新过的数据，一旦事务A回滚，事务B之前更新、查询过的数据就没了

`若事务A在事务B提交之后才回滚会是什么结果`

#### 不可重复读

#### 幻读

#### SQL标准下的四种事务隔离级别

注意是**SQL标准**，不是MySQL独有

- 读未提交

- 读已提交（RC）

- 可重复读（RR）

- 串行化

MySQL的RR级别可以避免幻读，也是默认的隔离级别



#### Spring事务

@Transactional注解只是作用于MySQL操作，其他JVM内存或网络操作不支持回滚



#### UndoLog版本链

数据行有两个隐藏字段

- trx_id -- 近一次更新这条数据的事务id

- roll_pointer -- 指向本事务更新前端生成的UndoLog



#### ReadView

开启事务时都会申请分配一个trx_id，这里是分配trx_id的数轴

<img src="E:\learning\Gunners-Java\Part1\4.数据库\pic\事务trx_id分配数轴.jpg" style="zoom:80%; float:left" />

红色代表事务开启时还未提交的事务trx_id

事务执行时会生成一个ReadView，记录在他**生成那一刻**MySQL存在事务的信息，相当于一个快照

ReadView中主要有4个元素（假设该事务分配到trx_id为11）：

- m_ids -- 此时所有在执行还没提交的事务id（9，11，13，15）
- min_trx_id -- m_ids里的最小值（9）
- max_trx_id -- 下一个要生成的事务id，即最大事务id（16）
- creator_trx_id -- 本事务id（11）

<img src="E:\learning\Gunners-Java\Part1\4.数据库\pic\事务开启时的trx_id数轴.jpg" style="zoom:80%; float:left" />



#### RC实现原理

当查询到事务B修改过数据且事务B还在运行，就顺着版本链下去找，这里搞明白

每次查询都重新开启一个ReadView，相当于获取当前最新的事务环境（快照）



#### RR实现原理

每次查询都基于第一次开启的ReadView去查询，不获取最新事务环境

trx_id小于min_trx_id，且不在m_ids集合中，说明事务在本事务开启之前已提交，可查

trx_id小于min_trx_id，且在m_ids集合中，说明事务在本事务开启时还没提交，不可查

trx_id大于max_trx_id ，说明事务在本事务开启之后才开启，不可查

`没搞明白版本链和数据行、undolog的关系，很迷`