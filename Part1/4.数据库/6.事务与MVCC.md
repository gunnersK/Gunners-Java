#### 脏写、脏读

事务B去更新、查询没提交的事务A更新过的数据，一旦事务A回滚，事务B之前更新、查询过的数据就没了

`若事务A在事务B提交之后才回滚会是什么结果`

#### 不可重复读

#### 幻读

#### SQL标准下的四种事务隔离级别

注意是**SQL标准**，不是MySQL独有

- 读未提交

- 读已提交（RC）

- 可重复读（RR）

- 串行化

MySQL的RR级别可以避免幻读，也是默认的隔离级别



#### Spring事务

@Transactional注解只是作用于MySQL操作，其他JVM内存或网络操作不支持回滚



#### UndoLog版本链

数据行有两个隐藏字段

- trx_id -- 近一次更新这条数据的事务id

- roll_pointer -- 指向本事务更新前端生成的UndoLog



#### ReadView

一个事务执行时会生成一个ReadView，记录在他**生成那一刻**MySQL存在事务的信息，相当于一个快照，有4个元素比较关键：

- m_ids -- 此时所有在执行还没提交的事务id

- min_trx_id -- m_ids里的最小值

- max_trx_id -- 下一个要生成的事务id，即最大事务id

- creator_trx_id -- 本事务id



#### RC实现原理

当查询到事务B修改过数据且事务B还在运行，就顺着版本链下去找，这里搞明白

每次查询都重新开启一个ReadView，相当于获取当前最新的事务环境（快照）



#### RR实现原理

每次查询都基于第一次开启的ReadView去查询，不获取最新事务环境

`没搞明白版本链和数据行、undolog的关系，很迷`