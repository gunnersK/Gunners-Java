[MySQL 执行计划详解](https://cloud.tencent.com/developer/article/1666118)

## 查询类型

- const

  直接聚簇索引，或者二级索引+聚簇索引回表查询，查询性能常量级（二级索引必须是唯一索引，unique，每个值都是唯一的）

  例如：select * from table where id = x

- ref

  普通二级索引或联合二级索引，对最左侧开始连续多个列进行等值查询

  如果使用了name IS NULL这种查询，即使name是主键的聚簇索引或二级唯一索引，那还是ref方式

- ref_or_null

  如果走二级索引，且有name IS NULL这种查询，就是ref_or_null方式

- range

  利用索引做范围查询

- index

  直接遍历二级索引叶子结点，不需回表聚簇索引查询

  例如：联合索引 index(x1, x2, x3)，select x1, x2, x3 where x2 = xxx，看起来x2不是联合索引最左侧字段，但是select的字段跟联合索引全部吻合，这时会直接遍历二级索引的叶子结点



如果sql中有若干个where条件，但只有一个字段用得到索引，就会先用这个字段到索引数中查出数据，在回表完整查询，把结果放入内存，再根据where中的其他字段进行筛选

所以如果有两个联合索引(x1, x3)，(x2, x4)，select * from table where x1=xx and x2>xx，会选择扫描行数较少的索引先查出记录，再回表完整查询，把结果拉到内存，根据x2>xx的条件进行筛选

若回表查询的数据量太大，则有可能同时到x1和x2各自的联合索引中查询数据，再取出交集得到较少的结果集，再回表查询







## 多表连接

先查驱动表所有数据，再遍历这些数据到被驱动表查询





## 执行计划选择

#### 全表扫描执行计划成本

IO成本1.0

CPU计算成本0.2

有多个可用索引，就是possible keys



#### 索引执行计划成本



#### 多表关联执行计划成本

跟单表差不多，只不过多查几个表







## 执行计划优化

MySQL会把sql中无用的括号去掉，或者做一些常量替换，本质都是优化sql语句的清晰语义

#### IN查询

select * from t1 where x1 in (select x2 from t2 where x3=xxx)

IN中的结果集会放入临时表，若数据太多可能用B+树的聚簇索引放磁盘，总之临时表会建立索引

查询时全表扫描t1表，然后到临时表根据索引快速查找

或者反过来全表扫描临时表，把每个数据回到t1表中根据字段索引查找 

下一个100