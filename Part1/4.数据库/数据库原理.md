# 一、 基础知识
### 1. 数据类型

   1. 整形
   
       * TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。
       
   2. 浮点
      
       * FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。
       
   3. 字符串
   
      * 主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。
      
   4. 时间日期
   
      1. DATETIME -- 从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。
      
      2. TIMESTAMP -- 保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

# 二、 数据库架构

1. 存储模块（文件系统）
   
2. 程序模块（管理存储的数据）

3. 影响程序运行的瓶颈是IO

# 三、索引 
https://blog.csdn.net/calledwww/article/details/79371040
- 定义：**排好序**的**快速查找**的数据结构

- 优势：减少IO，减少运算
	```
	提高检索效率，降低磁盘IO成本
	索引对数据进行排序，降低排序成本，降低CPU消耗
	```
- 缺点
	```
	需要占空间
	降低表的写操作（insert、update、delete），每次写操作之后都要更新加了索引字段的索引	
	如果数据量大，还需要花时间研究建立最优秀的索引（比如根据用户查询偏好，修改索引结构）
	```
- 哪些情况适合建索引
	```
	主键自动建立唯一索引
	频繁作为查询的字段
	外键字段
	排序字段，建索引会大大提高排序速度
	统计或分组字段（groupby之前也需要排序）
	```
- 哪些情况不适合建索引
	```
	where条件用不到的字段
	表记录太少
	频繁增删改的表
	数据重复率太高且分布平均（索引列不同值的数目/总记录数，值越接近1，索引效率越高）
  ```

1. 索引里面存的是什么
   1. 索引把数据**表中某一列的所有值以及每个值所在行对应的行的地址**以某种数据结构存储起来，也就是说，索引中的Employee_Name这列的某个值（或者节点）可以描述为 (“Jesus”, 0x82829)， 0x82829 就是包含 “Jesus”那行数据在硬盘上的地址。如果没有这个引用，你就只能访问到一个单独的值（“Jesus”），而这样没有意义，因为你不能获取这一行记录的employee的其他值-例如地址（address）和年龄（age）。
   
2. 什么信息能成为索引
   1. 能把信息限定在一定范围内的字段，如主键、唯一键、普通键等，只要能让数据具备一定区分性的字段
   
3. 索引是怎么工作的
   1. 假设在 Employee_Name这一列上创建一个B-Tree索引。这意味着当我们查找姓名是‘Jesus’的雇员时，不需要再扫描全表，只需去索引找到Jesus记录对应的行地址去直接找到行的位置，就可以获取其他列的信息
   
4. 实现索引的数据结构
   1. 二叉查找树、B树、主流B+树、Hash   mysql不支持BitMap
   
5. 密集索引和稀疏索引区别

6. 使用索引的代价
   1. 索引会占用空间，你的表越大，索引占用的空间越大
   
   2. 性能损失（值更新操作），当你在表中添加、删除或者更新行数据的时候，在索引中也会有相同的操作，因为建立在某列（或多列）索引需要保存该列最新的数据。
   
7. 什么时候要创建索引   
   1. 如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引
   
   2. 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效
   
   3. 对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。

8. 如何定位并优化慢查询Sql

   1. 根据慢日志定位慢查询sql
   
   2. 使用explain等工具分析sql
   
   3. 修改sql或者尽量让sql走索引
   
# 四、锁和事务   

1. 为什么要有事务
   1. 为数据库操作提供了一个从失败中恢复到正常状态的方法，保证数据库在异常状态下仍能保持**一致性**。
   
   2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个**隔离**方法，保证彼此的操作互相干扰。

1. MyISAM与InnoDB关于锁方面的区别

   1. MyISAM默认用表级锁，不支持行级锁，不支持事务，不支持外键；InnoDB默认用行级锁，也支持表级锁，支持事务，支持外键，是 MySQL 默认的事务型存储引擎
   
   2. MyISAM引擎
   
      1. 当表进行select的时候，会自动给整张表上一个表级的读锁，并且阻塞其他session对表的更新，即当读锁未被释放，另一个session要对表加写锁，就会被阻塞
      
      2. 当表进行增删改的时候，会自动给整张表上一个表级的写锁
      
      3. 读锁（共享锁）
      
         1. 先上读锁的同时，另一个session也可以对表加读锁，即上共享锁时，依然支持上共享锁，在一个session进行范围查询的时候，另一个session依然能对表进行读操作
         
         2. 但是当一个session给表上了读锁，另一个session要进行写操作就会被阻塞了，尽管要写的行不是正在读的那些行，因为他锁住的是整张表，而不是正在读的行
         
         3. select也可以像写锁一样上一个排它锁：select * from table_name **for update**，这样一个session上读锁时，別的session就上不了读锁
         
      4. 写锁（排它锁）
      
         1. 一个session上写锁的时候，另一个session不能进行读写操作，不能上读写锁，会被阻塞
      
      5. 显式给表加锁
      
         1. lock tables table_name read/write
         
         2. unlock tables
         
      6. 总结
      
         1. 共享锁：上共享锁之后，依然支持上共享锁，不支持上排它锁
         
         2. 排它锁：上排它锁之后，不支持上其他锁
   
2. 数据库事务四大特性(ACID)

   1. 原子性（Atomic）：事务包含的所有操作要么全执行，要么全失败回滚
   
   2. 一致性（Consistency）：事务应确保数据库的状态从一个一致的状态变为另一个一致的状态，**一致性与原子性是密切相关的**。AB账户加起来2000，不管A转账多少给B，事务结束后AB加起来还是2000
   
      * 一致状态的含义：数据库的数据应满足完整性约束
      
   3. **隔离性（Isolation）：** 多个事务并发执行时，一个事务的执行不应该影响其他事务的执行
   
   4. 持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中

**3. 事务隔离级别以及各级别下的并发访问问题**

   1. 事务并发访问引起的问题
   
      1. **更新丢失--READ UNCOMMITTED：** READ UNCOMMITTED事务隔离级别以上避免(mysql所有事务隔离级别在数据库层面上均可避免)--任何操作都**不会加锁**，数据库一般都不会用
      
      2. **脏读--READ-COMMITTED：** 一个事务读到另一个事务未提交的更新数据，可以在READ-COMMITTED事务隔离级别以上避免--数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的
      
         1. 查看当前隔离级别：select @@tx_isolation
         
         2. 成因：把两个session都设置为最低的事务隔离级别：set session transaction isolation level **read uncommitted**，都开启事务：start transaction，session1把字段从1更新为2但不提交，并查询，session2查询，结果和session1查询的一样都是2，这时session1回滚，字段变回原来的1，但是session2仍按字段是2的值去更新并提交，这就发生了脏读
         
         3. 解决：把两个session都设置为set session transaction isolation level **read committed**，都开启事务：start transaction，session1更新字段为2但不提交，并查询，session2查询，结果字段不是session1更新后的2，而是原来的1，这时session1回滚，字段变回原来的2，这时就算session2仍按字段是1的值去更新并提交，也不是脏读了
         
      3. **不可重复读--REPEATABLE-READ：** 事务A多次读取同一数据，事务B在事务A读取数据的过程中，对数据进行了更新并提交，导致事务A多次读取同一数据的结果不一致，REPEATABLE-READ事务隔离级别以上可避免--读取数据时加行级读锁
      
         1. 成因：把两个session都设置为set session transaction isolation level read committed，都开启事务，从session1的角度看，先读一次字段，值是1，再切换到session2的角度，把字段更新为2并提交，再切换回session1，再读一次字段，发现值是2，和上次的数据不一致，这就发生了不可重复读
         
         2. 解决：把两个session都设置为set session transaction isolation level **repeatable read(默认事务隔离级别)**，都开启事务：start transaction，从session1的角度看，先读一次字段，值是1，再切换到session2的角度，把字段更新为2并提交，再切换回session1，再读一次字段，发现值还是1，即尽管session2做出修改并提交了之后，session1读到的值还是原来未提交的值，这就避免了不可重复读的情况。但是这个时候session1对字段做出修改，是在字段最新的值2之上进行修改的，这也不会导致数据不一致的情况
         
      4. **幻读--SERIALIZABLE：** 事务A读取与搜索条件相匹配的若干行，事务B以插入或删除行等方式来修改事务A的结果集，导致事务A看起来像出现幻觉一样，SERIALIZABLE事务隔离级别可避免--读加共享锁，写加排他锁，读写互斥
      
         1. 成因：把两个session都设置为set session transaction isolation level read committed，都开启事务，session1使用当前读的方式查询一下，并加了一个共享锁，查出来20条记录，紧接着session2添加一条数据，发现在这个级别下，session2可以操作成功，提交，回到session1，给表的某个字段全部更新为'a'，这时发现，竟然有21行受影响，本来是对20条数据进行更新，现在变成了21条，这就出现了幻读
         
            * ps：因为mysql在repeatable read级别下也可以避免幻读，所以要用read committed进行测试
         
         2. 解决：把两个session都设置为set session transaction isolation level **serializable(最高事务隔离级别)**，都开启事务：start transaction，重复以上操作，从session1的角度查询一下，查出来20条，再切换到session2，添加一条数据，这时发现被阻塞了，需要等session1提交或回滚之后才能执行插入操作，这是因为serializable级别下，所有操作都会加锁，这就避免了幻读的发生
         
      5. 归纳 
         1. 不可重复读和幻读的区别：
            1. 在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。
            
            2. 不可重复读的和幻读很容易混淆，不可重复读侧重于**修改**，幻读侧重于**新增或删除**。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。
         
         2. 事务隔离级别越高，安全性更高，**一致性**更高，但是串行化也更高，应该根据具体业务需要选择合适的事务隔离级别
         
         3. 默认隔离级别
         
            1. mysql：repeatable read
            
            2. Oracle：read committed
            
         4. 归纳一下四种事务隔离机制是如何用锁解决各种并发访问的问题的？

4. 当前读和快照读
   1. 当前读：加了锁（共享或排他）的增删改查语句，他读取的是记录的最新版本，并且保证读取之后其他并发事务不能修改当前记录，对读取的记录加锁

4. InnoDB可重复读隔离级别下如何避免幻读

5. RC、RR级别下的InnoDB的非阻塞读如何实现

# 五、优化 
#### 常见性能瓶颈
- cpu：在饱和的时候，一般发生在数据装入内存或从磁盘上读取数据的时候
- io：磁盘io瓶颈，发生在装入数据远大于内存容量的时候
- 硬件性能瓶颈
*ps：一般数据量到300万就该优化了*
#### 查询优化器
- mysql有自带的查询优化器，会对语句按mysql自己的优化规则进行优化，但效率不一定是最优的，需要人去分析以找到最优的sql。比如一条sql，优化器会用到某个索引，但其实强制指定用另一个索引查询效率会更高
#### 优化思路
- 去硬盘的慢日志文件中找到慢查询sql
- explain分析慢sql
- 优化sql
- 建索引
#### explain
- 作用
	- 表的读取顺序
	- 数据读取操作的操作类型
	- 哪些索引可以使用
	- 哪些索引被实际使用
	- 表之间的引用
	- 每张表有多少行被优化器查询
- 包含的字段：id, select_type, table, type, possible_keys, key, key_len, ref, rows, extra
	- id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序，有三种情况
    ``` 
    id相同，执行顺序由上至下
    id不同，如果有子查询，id会递增，id越大越先被执行
    id有相同有不同，数字大的先执行，数字相同的，平级的由上到下执行
    ```
	- select_type
    ```
    SIMPLE：简单的select查询，不包含子查询或union
    PRIMARY：若查询中有任何复杂的子部分，则用来标记最外层的查询
    SUBQUERY：在select或where列表中包含了子查询
    DERIVED：在from列表中包含的子查询被标记为DERIVED，mysql会递归执行这些子查询，把结果放在临时表里
    UNION：若第二个select出现在union之后，则被标记为UNION；若union包含在from子句的子查询中，外层select将被标记为DERIVED
    UNION RESULT：从union表获取结果的select(两个被union拼起来的select)
    ```
	- possible_keys, key
    ```
    possible_keys：mysql自己判断理论上用到哪些索引
    key：实际用到的索引，查询中如果使用了覆盖索引，则该索引不出现在possible_keys列表，仅出现在key列表中
    覆盖索引：select的字段和建的复合索引字段的个数和顺序一一一致 
    ```
	

# 六、范式
https://www.cnblogs.com/wsg25/p/9615100.html
1. 第一范式

   1. 要求数据库表的每一列都是不可分割的原子数据项。
   
   2.

2. 第二范式

   1. 第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）
   
   2. 

3. 第三范式

   1.  第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

# 七、连接池和并发
1. 创建连接很费资源，数据库连接池保持现有连接后不会再创建连接池，而是复用这些连接

2. 连接池里面有个队列，如果并发超过连接池连接数，则连接在队列里排队等待，直至有空余的连接，超过等待连接就断开

3. 如果并发远远超出一个数据库的承受能力

   1. 使用缓存，减少查询连接（读多）
   
   2. 使用数据库集群，增加节点，读写分离（写多）
   
   3. 使用分布式消息队列（写多）
   
   4. 使用微服务，一个业务模块一个数据库
