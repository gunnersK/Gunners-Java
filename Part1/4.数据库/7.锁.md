- 事务上锁时，会创建一个锁，包含自己的trx_id和等待状态，然后与这行数据关联在一起（锁和数据都在内存中）

- 事务同时更新一行数据都会加锁，排队等待，执行完毕释放锁才轮到别的事务执行

- 更新数据会加独占锁（X锁，Exclude）

  此时其他事务加不了任何锁，即不能更新数据

  此时读取这行数据，默认开启MVCC机制（MVCC就是避免频繁加锁互斥，提高并发）

- 读取数据也可以加共享锁（S锁，Share）：select * from table lock in share mode

  因为**S锁和X锁互斥**，所以S锁不能加在已经加了X锁的记录，X锁也不能加载已经加了S锁的记录

  **S锁和S锁不互斥**，所以一行数据可以加多个S锁



#### 表级锁

表级锁，比如alter table之类的操作，会加表级锁，阻塞所有增删改操作

- 事务执行写操作，会自动在行级加独占锁，在表级加**意向独占锁**
- 事务执行读操作，会自动在表级加**意向共享锁**

意向锁之间不互斥

|            | 独占锁 | 意向独占锁 | 共享锁 | 意向共享锁 |
| ---------- | ------ | ---------- | ------ | ---------- |
| 独占锁     | 互斥   | 互斥       | 互斥   | 互斥       |
| 意向独占锁 | 互斥   | 不互斥     | 互斥   | 不互斥     |
| 共享锁     | 互斥   | 互斥       | 不互斥 | 不互斥     |
| 意向共享锁 | 互斥   | 不互斥     | 不互斥 | 不互斥     |

