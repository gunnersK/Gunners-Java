## 脏写的避免

当多个事务并发更新同一行数据时，就会引发脏写

所以需要利用锁机制来让多个写事务串行执行，以避免脏写

**所有事务隔离级别均可避免脏写：**

当事务A修改数据行row时，会创建一个**行级独占锁结构**，保存自己的trx_id和等待状态，然后和row关联起来

因为是对BP中的数据行操作的，所以row和锁结构都在内存中

只有事务A修改完并且提交，才会释放锁

若事务A提交之前事务B也尝试修改row，发现row被事务A锁住了

那么事务B也会创建一个锁结构，将等待状态设为true，排队等待

当事务A提交之后，释放锁，他会找是否有其他事务对row加了锁且处于等待状态

这时就会找到事务B，然后将事务B的等待状态改为false，事务B就获取到row的锁了









## 行级锁

#### 行级独占锁

更新数据会加独占锁（X锁，Exclude）

此时其他事务加不了任何锁，即不能更新数据

此时读取这行数据，默认开启MVCC机制（MVCC就是避免频繁加锁互斥，提高并发）



#### 行级共享锁

读取数据也可以加共享锁（S锁，Share）：select * from table lock in share mode

因为**S锁和X锁互斥**，所以S锁不能加在已经加了X锁的记录，X锁也不能加载已经加了S锁的记录

**S锁和S锁不互斥**，所以一行数据可以加多个S锁









## 表级锁

表级锁，比如alter table之类的操作，会加表级锁，阻塞所有增删改操作

#### 表级独占锁

LOCK TABLES XXX WRITE（一般不手动加）



#### 表级共享锁

LOCK TABLES XXX READ（一般不手动加）



#### 表级意向独占锁

事务执行写操作，会自动在行级加独占锁，同时在表级加**意向独占锁**



#### 表级意向共享锁

事务执行读操作，会自动在表级加**意向共享锁**



意向锁之间不互斥

|              | 表独占锁 | 表意向独占锁 | 表共享锁 | 表意向共享锁 |
| ------------ | -------- | ------------ | -------- | ------------ |
| 表独占锁     | 互斥     | 互斥         | 互斥     | 互斥         |
| 表意向独占锁 | 互斥     | 不互斥       | 互斥     | 不互斥       |
| 表共享锁     | 互斥     | 互斥         | 不互斥   | 不互斥       |
| 表意向共享锁 | 互斥     | 不互斥       | 不互斥   | 不互斥       |









## 间隙锁









## 锁升级









## 锁实现原理

封装了OS提供的基本互斥量（mutex）和信号量（event）

https://blog.csdn.net/wenyiCodeDog/article/details/106652071