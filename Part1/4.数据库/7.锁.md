## 脏写的避免

当多个事务并发更新同一行数据时，就会引发脏写

所以需要利用锁机制来让多个写事务串行执行，以避免脏写

**所有事务隔离级别均可避免脏写：**

当事务A修改数据行row时，会创建一个**锁结构**，保存自己的trx_id和等待状态，然后和row关联起来

只有事务A修改完并且提交，才会释放锁

若事务A提交之前事务B也尝试修改row，发现row被事务A锁住了

那么事务B也会创建一个锁结构，将等待状态设为true，排队等待

当事务A提交之后，释放锁，他会找是否有其他事务对row加了锁且处于等待状态

这时就会找到事务B，然后将事务B的等待状态改为false，事务B就获取到row的锁了





- 事务上锁时，会创建一个锁，包含自己的trx_id和等待状态，然后与这行数据关联在一起（锁和数据都在内存中）

- 事务同时更新一行数据都会加锁，排队等待，执行完毕释放锁才轮到别的事务执行

- 更新数据会加独占锁（X锁，Exclude）

  此时其他事务加不了任何锁，即不能更新数据

  此时读取这行数据，默认开启MVCC机制（MVCC就是避免频繁加锁互斥，提高并发）

- 读取数据也可以加共享锁（S锁，Share）：select * from table lock in share mode

  因为**S锁和X锁互斥**，所以S锁不能加在已经加了X锁的记录，X锁也不能加载已经加了S锁的记录

  **S锁和S锁不互斥**，所以一行数据可以加多个S锁

独占锁，意向独占锁，共享锁，意向共享锁，行锁，表锁，页锁，间隙锁、锁升级

#### 表级锁

表级锁，比如alter table之类的操作，会加表级锁，阻塞所有增删改操作

- 事务执行写操作，会自动在行级加独占锁，在表级加**意向独占锁**
- 事务执行读操作，会自动在表级加**意向共享锁**

意向锁之间不互斥

|            | 独占锁 | 意向独占锁 | 共享锁 | 意向共享锁 |
| ---------- | ------ | ---------- | ------ | ---------- |
| 独占锁     | 互斥   | 互斥       | 互斥   | 互斥       |
| 意向独占锁 | 互斥   | 不互斥     | 互斥   | 不互斥     |
| 共享锁     | 互斥   | 互斥       | 不互斥 | 不互斥     |
| 意向共享锁 | 互斥   | 不互斥     | 不互斥 | 不互斥     |



#### 锁实现原理

封装了OS提供的基本互斥量（mutex）和信号量（event）

https://blog.csdn.net/wenyiCodeDog/article/details/106652071