67-90

## 消息丢失

67-74

#### 原因

- 生产者由于网络通信原因，导致消息投递失败
- MQ本身故障，消息还在Cache中就宕机or重启，或消息写入磁盘后磁盘损坏
- 消费者提交offset之后，还没处理好对应业务，消费者机器就重启or宕机



#### 生产者搞丢

##### 事务消息

- 生产者先给Broker发一个half消息，half对消费者不可见
- Broker给生产者返回half消息写入成功的通知
- 生产者执行本地事务，选择commit或rollback
- 生产者根据本地事务的commit或rollback情况，向MQ发送commit或rollback消息
- 若MQ接收到commit，就对half消息进行commit操作，使消费者可见
- 若MQ接收到rollback，就把half消息删除
- MQ有个补偿流程，需要生产者实现一个接口，MQ会定时扫描处于half状态的消息，然后回调接口，由生产者告诉MQ需要对half消息进行commit还是rollback操作

这其中会有网络异常、机器宕机等各种情况会导致操作失败，使得流程无法按预期进行，要再总结68，69

##### 实现原理

69



#### MQ搞丢

使用同步刷盘策略，消息落盘后才给生产者返回ACK，避免消息还在Cache中就宕机or重启

使用主从架构的模式避免消息写入磁盘后磁盘损坏

72



#### 消费者搞丢

处理完业务再提交offset，不要异步处理业务

自动故障转移：RocketMQ能感知到宕机的consumer机器，会自动把该机器还没处理完的消息交给消费者组中其他机器处理，避免消息丢失

73



#### 代价

做好以上几个环节，即可实现消息零丢失，但是这样会极大降低消息吞吐量，成本很高，一般只有在跟钱相关之类的极其核心的链路才做零丢失方案

普通场景中，丢一些消息也问题不大，可以对以上几个环节做一些简化

比如可以把事务消息方案简化为同步发送消息 + 重试机制

或者把MQ同步刷盘改为异步刷盘

或者让消费者提交offset后再异步处理业务

74









## 重复消费

#### 原因

- 生产者被别的系统rpc重复调用
- 生产者没有收到MQ的ACK，重试投递消息，造成重复
- 消费者处理完业务，且还没提交offset，就宕机了



#### 解决方案

- 生产者别重复发
  - RocketMQ是支持你查询某个消息是否存在，但是性能不好
  - 业务判断，比如到数据库中判断业务是否执行过
  - redis记录（极端情况小比如还没记进redis就宕机了，还是保证不了幂等性）
- 消费者别重复消费
  - 业务判断，比如到数据库中判断业务是否执行过
  - redis记录（极端情况小比如还没记进redis就宕机了，还是保证不了幂等性）

一般可以接受生产者往MQ重复发送消息，但是要在消费者端保证不重复处理

75-76









## 顺序消费

同一类需要顺序消费的消息都让生产者给他路由发送到同一个MessageQueue中，让他被同一个消费者消费，即可保证顺序消费

比如对同一条DB记录的更新和查询操作，必须保证先更新后查询，就可以根据记录的主键id，对MessageQueue总数取模得到MessageQueue的序号，然后发送到那个MessageQueue中去

78-80









## 消息积压

如果MessageQueue比消费者机器多一些，比如有20个MessageQueue，4个消费者机器消费，就可以开到20个消费者机器快速消费掉

如果MessageQueue跟消费者机器差不多，可以开较多个新的MessageQueue，让消费者把消息读出来，不要处理消息的业务，直接写进新的MessageQueue中，然后使用较多的新的消费者快速消费新的MessageQueue

87