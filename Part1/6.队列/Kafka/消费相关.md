## Consumer

#### 主要参数

- session.timeout.ms -- group成员宕机时被协调者coordinator发现的时间

- max.poll.interval.ms -- 处理消息的最大时间

```java
通过将max.poll.interval.ms设置成实际的逻辑处理时间，再结合较低的session.timeout.ms参数值，consumer group 既实现了快速的 consumer 崩溃检测，也保证了复杂的事件处理逻辑不会造成不必要的 rebalance
```

- heartbeat.interval.ms `不理解`

- auto.offset.reset `不理解`

- connections.max.idle.ms: 空闲连接最大存活时间



#### 获取消息

consumer.poll(ms)

ms是超时参数，控制最大阻塞时间，类比product的batch，当获取足够多的消息则立即返回，否则阻塞，超时则返回



#### 重平衡

消费group中某个节点宕机，会立即将其负责的分区交给其他节点负责，称为重平衡

（下面详细展开）









## offset

#### 原理

offset格式是KV对：key是group.id + topic + partition.id，value则是offset的值

<img src=".\pic\各种offset.jpg" style="zoom:80%; float:left" />

watermark（水位）右边属于未被写入成功的消息，不可读取，只能读取watermark左边的消息

如果同一个group的消费节 点向同一个分区提交多条消息的offset，只有最新提交的offset才是有用的，Kafka通过compact策略来保留最新提交的offset



#### 内部topic

早期Kafka将offset直接维护在ZK中，但ZK是分布式协调工具，同时用来存储数据性能差，不适合进行频繁高并发读写操作

从0.9.0.0开始，Kafka维护一个内部topic（__consumer_offsets）来保存提交的offest

内部topic有50个分区，用以将consumer提交的offset用group.id哈希取模打散保存，应对高并发提交offset场景



#### 自动/手动提交

- 自动提交 -- 后台线程每5s提交一次位移（旧版Kafka默认60s，新版5s）

- 手动提交 -- 可以确保消息被真正处理完后再提交位移

  - 同步提交 -- commitSync()方法，阻塞方法，等待offset提交结束才返回

  - 异步提交 -- commitAsync()方法，非阻塞方法，并非用单独线程提交，而是提交后会在主线程的poll()方法中不断轮询这次异步提交的结果

    `猜测：poll方法轮询到提交结果之前是否不能继续拉取消息？`









## 重平衡

#### 定义

Kafka会选举某个broker作为组协调者（group coordinator)，负责对组的状态进行管理，当新成员到达时对组内成员重新进行消费平衡操作

成功rebalance后，group内所有consumer要定期向coordinator发送心跳，每个consumer也是根据心跳请求的想要中是否包含 **REBALANCE_IN_PROGRESS** 判断所在group是否开启新一轮rebalance



#### 触发条件

- 组成员加入、离开、崩溃（最常见）
- 组订阅topic数变更
- 组订阅topic的分区数变更

`5.6.2，归纳线上频繁rebalance情况调优`



#### 分配策略

- range -- 范围（新版本默认） `没懂`
- round-robin -- 轮询
- sticky -- 0.11.0.0版本引入 `没懂`



#### 重平衡组版本

rebalance generation

初始值0，每次rebalance后 +1

用来保护group，防止提交无效offset，比如上一届的group成员延迟提交了 offset，但rebalance之后该group产生了新一届的group成员，而这次延迟的offset提交携带的是旧generation信息，因此这次提交会被consumer group拒绝，会导致 **ILLEGAL_GENERATION** 异常



进度：5.6.6 rebalance流程