## Consumer

#### 主要参数

- session.timeout.ms -- group成员宕机时被协调者coordinator发现的时间

- max.poll.interval.ms -- 处理消息的最大时间

```java
通过将max.poll.interval.ms设置成实际的逻辑处理时间，再结合较低的session.timeout.ms参数值，consumer group 既实现了快速的 consumer 崩溃检测，也保证了复杂的事件处理逻辑不会造成不必要的 rebalance
```

- heartbeat.interval.ms `不理解`

- auto.offset.reset `不理解`

- connections.max.idle.ms: 空闲连接最大存活时间



#### 获取消息

consumer.poll(ms)

ms是超时参数，控制最大阻塞时间，类比product的batch，当获取足够多的消息则立即返回，否则阻塞，超时则返回



#### 重平衡

消费group中某个节点宕机，会立即将其负责的分区交给其他节点负责，称为重平衡

（下面详细展开）









## offset

#### 原理

offset格式是KV对：key是group.id + topic + partition.id，value则是offset的值

<img src=".\pic\各种offset.jpg" style="zoom:80%; float:left" />

watermark（水位）右边属于未被写入成功的消息，不可读取，只能读取watermark左边的消息

如果同一个group的消费节点向同一个分区提交多条消息的offset，只有最新提交的offset才是有用的，Kafka通过compact策略来保留最新提交的offset



#### 内部topic

早期Kafka将offset直接维护在ZK中，但ZK是分布式协调工具，同时用来存储数据性能差，不适合进行频繁高并发读写操作

从0.9.0.0开始，Kafka维护一个内部topic（__consumer_offsets）来保存提交的offest

内部topic有50个分区，用以将consumer提交的offset用group.id哈希取模打散保存，应对高并发提交offset场景



#### 自动/手动提交

`自动提交间隔 5 秒，从何时开始计时5秒？`

- 自动提交 -- 后台线程每5s提交一次位移

- 手动提交 -- 可以确保消息被真正处理完后再提交位移



p122异步手动提交