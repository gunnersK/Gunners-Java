## 主从复制

Slave节点有一个IO线程与Master建立TCP连接

Master有一个dump线程把增删改binlog日志通过这个TCP连接发送给Slave

Slave把接收到的binlog日志写入本地relay日志文件

Slave另一个线程把relay日志文件的增删改内容在自己DB上执行一遍，进行日志重做，同步Master的操作



#### 半同步复制

搭建主从复制架构一般都用半同步复制方式

Master写入数据，得保证binlog日志给到从库了才返回事务成功

否则当写入的binlog还没同步到Slave，Master就宕机了，Slave再切换为Master，数据就丢了

搭建方式：传统方式、gtid



#### 数据延迟

从库多线程并行复制数据 / 读请求强制走主库



#### HA

使用MHA







## 分库分表

按业务id分库分表

建立索引映射表，对索引进行分库分表，把索引拆分到对应各个库中

把数据同步到ES去做复杂搜索



> 分库分表几年后数据又太大了咋办？
>
> 刚开始分库分表时应该估算数据增量，把表数量拆多一点，宁可每张表的数据少一点



#### 分布式id

- 独立DB自增id

  每次往一个独立DB插入数据，获取自增id，再往分库分表写

  但是高并发时独立DB扛不住

- 随机uuid

  uuid太常见了，不适合用于主键，新增无序的主键会导致频繁页分裂

  uuid常用于文件名、编号

- 系统时间戳

  短时间内并发会导致时间戳主键重复

- Snowflake算法（雪花算法）

  64bit的long类型

  1个bit不用 -- 表示正负

  41个bit时间戳

  10个bit工作机器id -- 5bit机房id（也可用表id代替，因为通常机房并没有那么多），5bit机器id

  12bit序列号 -- 某一毫秒内同时生成的id序号

ry128、129、130