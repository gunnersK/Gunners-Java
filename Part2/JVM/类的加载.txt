1.类加载的全过程：加载，连接，初始化



2.加载 
   将class文件中的字节码加载到内存中，字节码的来源可以有：硬盘、网络、数据库或jar包等
   类加载到方法区中形成二进制数据，在堆里形成Class对象

   1.通过一个类的全限定名来获取此类的二进制字节流

   2.将字节流所代表的静态存储结构转化为运行时数据结构，加载到方法区(按照虚拟机所需格式存储在方法区中)

   3.在java堆实例化一个该类的Class对象

   加载阶段和连接阶段的部分内容(如一部分字节码文件格式验证)是交叉进行的，这些夹在加载阶段
   之中的动作仍然属于连接阶段的内容，此时加载阶段尚未完成



3.连接
   将方法区的二进制数据合并到JVM的运行状态之中（从静态数据变成运行时数据）

   1.验证（未懂）：确保Class文件的字节流包含的信息符合虚拟机要求，且不会危害虚拟机
              1.文件格式验证
              2.元数据验证
              3.字节码验证
              4.符号引用验证

   2.准备：为类变量分配内存并设置类变量初始值，都在方法区进行分配
              1.这里只是对static变量在java堆分配内存，不包括实例变量，这个在对象实例化时才分配

              2.这里的类变量初始值只是赋予数据类型的零值，只有final的static变量才会被赋予指定值
                    例如：public static int a = 22;  a变量在准备阶段过后的初始值是0而不是22
                              public static final int a = 22;  这时a变量在准备阶段就会被赋值为22了

              3.这也就很好的说明了为何引用类的final静态变量不会引发类的初始化而引用static变量就
                 会了，因为final静态变量在初始化之前已经被赋值了

   3.解析（未懂）：每个类都有一个常量池，这个阶段是虚拟机将常量池内的符号引用替换为直接引用的过程 
              1.解析有时可以在初始化阶段之后开始，这是为了支持java的运行时绑定



4.初始化
   1.初始化是执行类构造器方法<clinit>()方法的过程

   2.把静态变量的赋值动作和静态语句块合并产生的就是类构造器方法
         注意：静态变量的赋值动作和static块是按照代码位置先后的顺序执行的

   3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先初始化父类
      所以虚拟机中第一个被执行<clinit>()方法的类肯定是Object

   4.<clinit>()方法对于类或接口不是必须的，如果一个类中没有static块或没有对变量的赋值操作，
      那么编译器可以不为这个类生成<clinit>()方法

   5.接口不能使用static块，但仍然有变量初始化的赋值操作，就会生成<clinit>()方法，但是初始化接口
      不需要执行父接口的<clinit>()方法，只有父接口定义的变量被使用才会执行

   6.接口实现类初始化也不会执行接口的<clinit>()方法

   7.虚拟机会保证一个类的初始化方法在多线程的环境中被正确加锁和同步（线程安全）

   8.只有第一次使用一个类时，才会执行该类的类构造器方法



5.类的主动引用和被动引用 --见截图
   1.主动引用（被初始化）：
         1.new 

         2.读取或设置一个类的static字段（final修饰的除外）

         3.调用一个类的静态方法

         4.第一次用反射的方法对类进行调用

         5.初始化一个类时，如果发现其父类还没有进行初始化，需要先初始化父类.
               但是！！接口在这个地方有点不同，接口在初始化时并不要求其父接口也初始化，只有在
               真正使用父接口时才会初始化

         6.执行main方法的那个类

    2.被动引用（不会被初始化）：
         1.子类引用父类的静态字段，不会初始化子类 

         2.通过数组定义引用类    A1[] a = new A1[3]



6.类加载器 
   1.绝大部分java程序会使用到这三种系统提供的类加载器	
       1.启动类加载器（Bootstrap ClassLoader）
           1.加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等
              或者被-Xbootclasspath参数所指定的路径中的
 
           2.这个类加载器用C++实现

       2.扩展类加载器（Extention ClassLoader）
           1.加载%JRE_HOME%\lib\ext目录下的jar包和class文件，或者被java.ext.dirs系统变量
              所指定的路径中的所有类库

       3.应用程序类加载器（Appclass Loader也称为SystemAppClass）
           1.加载当前应用的classpath（用户类路径）上指定的的所有类

   2.类加载器之间虽然是父子关系，但他们是组合的，不是继承的

   3.一个类被不同加载器加载那么他们就不是==的

   4.双亲委派模型
       1.所有子加载器在加载类的时候都会委托上一级父加载器加载，父加载器加载不了才会让子加载器加载
     
       2.好处：保证java核心库的类型安全，如果你自己定义了一个和核心库里面包名类名都一样的类，
          也加载不了，只有核心库里面的类才会被加载