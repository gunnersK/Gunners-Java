![](D:\Learning\Gunners-Java\Part2\JVM\pic\2.png)

![](D:\Learning\Gunners-Java\Part2\JVM\pic\3.png)

#### 常用命令

-XX:+PrintCommandLineFlags 类名

最大最小堆大小最好设置为一样，不要弹性扩展收缩，浪费计算资源

GC日志

-Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGCDetails 

![](D:\Learning\Gunners-Java\Part2\JVM\pic\4.GC日志.png)

heap dump

当堆oom之后，会把整个堆dump出来

 ![](D:\Learning\Gunners-Java\Part2\JVM\pic\5.heap dump.png)eden
起始地址，使用空间结束地址，内存空间结束地址
total = eden + 1个survivor

Metaspace
reserved：预留总大小
committed：先占用的大小
capacity：在占用的空间中使用多少作为整体容量 
userd：真正使用大小 

#### 调优前的概念

- 吞吐量：用户代码执行时间  /（用户代码执行时间 + 垃圾回收时间）

- 响应时间：STW越短，响应时间越好

调优要确定追求啥？吞吐量还是响应时间优先？还是满足一定响应时间情况下，要求达到多大吞吐量？

根据不同项目性能要求进行压测，达不到要求则调优，调不了加内存加CPU

吞吐量优先：科学计算、数据挖掘等，用PS + PO

响应时间优先：一般是网站，带界面的，或API接口，  用CMS + PN、G1(1.8)

#### 什么是调优 

根据需求进行JVM规划和预调优

优化运行JVM运行环境（慢，卡顿） 

解决JVM运行过程中出现的各种问题（OOM） 

#### 调优规划

- 先用一台机器，试试能支撑多少，在这个基础上慢慢扩展，没有业务场景的调优都是耍流氓
- 无监控（压测），不调优
- 有的是业务本身不合理，非得让计算实现，只能优化业务

![](D:\Learning\Gunners-Java\Part2\JVM\pic\6.调优步骤.png)

- 内存需求弹性大，内存越大GC时间越长，反而不好，内存小多GC几次就行了，反而提高效率
- 选定CPU，越高越好

- 日志参数：114-0148

![](D:\Learning\Gunners-Java\Part2\JVM\pic\案例1.png)

每台机器1w并发，redis扛得住，10k问题

大流量处理方法：分而治之