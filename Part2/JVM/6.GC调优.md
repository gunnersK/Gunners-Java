![](D:\Learning\Gunners-Java\Part2\JVM\pic\2.png)

![](D:\Learning\Gunners-Java\Part2\JVM\pic\3.png)

#### 常用命令

![](.\pic\GC参数.png)

-XX:+PrintCommandLineFlags 类名

最大最小堆大小最好设置为一样，不要弹性扩展收缩，浪费计算资源

GC日志

-Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGCDetails 

![](D:\Learning\Gunners-Java\Part2\JVM\pic\4.GC日志.png)

heap dump

当堆oom之后，会把整个堆dump出来

 ![](D:\Learning\Gunners-Java\Part2\JVM\pic\5.heap dump.png)eden
起始地址，使用空间结束地址，内存空间结束地址
total = eden + 1个survivor

Metaspace
reserved：预留总大小
committed：先占用的大小
capacity：在占用的空间中使用多少作为整体容量 
userd：真正使用大小 

#### 调优前的概念

- 吞吐量：用户代码执行时间  /（用户代码执行时间 + 垃圾回收时间）
- 响应时间：STW越短，响应时间越好

```
不是很理解
```

调优要确定追求啥？吞吐量还是响应时间优先？还是满足一定响应时间情况下，要求达到多大吞吐量？

根据不同项目性能要求进行压测，达不到要求则调优，调不了加内存加CPU

吞吐量优先：科学计算、数据挖掘等，用PS + PO

响应时间优先：一般是网站，带界面的，或API接口，  用CMS + PN、G1(1.8)

#### 什么是调优 

根据需求进行JVM规划和预调优

优化运行JVM运行环境（慢，卡顿） 

解决JVM运行过程中出现的各种问题（OOM） 

#### 调优规划

- 先用一台机器，试试能支撑多少，在这个基础上慢慢扩展，没有业务场景的调优都是耍流氓
- 无监控（压测），不调优
- 有的是业务本身不合理，非得让计算实现，只能优化业务

![](D:\Learning\Gunners-Java\Part2\JVM\pic\6.调优步骤.png)

- 内存需求弹性大，内存越大GC时间越长，反而不好，内存小多GC几次就行了，反而提高效率
- 选定CPU，越高越好

- 日志参数：114-0148

![](D:\Learning\Gunners-Java\Part2\JVM\pic\案例1.png)

每台机器1w并发，redis扛得住，10k问题

大流量处理方法：分而治之

![](D:\Learning\Gunners-Java\Part2\JVM\pic\JVM实际问题.png)



#### OOM排查流程

![](D:\Learning\Gunners-Java\Part2\JVM\pic\排查流程.png)

top -Hp 进程号  

7.jstack：用来排查死锁之类的问题，写一个死锁程序，用jstack观察，一堆线程WAITING BLOCKED，找到有一个线程一直RUNNABLE的就是死锁

14.使用MAT/jhat进行dump文件分析

线程，尤其是线程池，要自定义有意义的名称（自定义ThreadFactory实现自定义线程池名称），方便排错回溯。用自定义线程池，不用java自带线程池

不要用jconsole、jvisualvm等JMX服务的图形界面连接远程JVM，会影响JVM主业务进程。上线前的压测可以用图形界面进行监控	

```
hotspot和openjdk区别？   
```

9.jmap -histo pid | head -20：打印前二十行， 列出类占多少字节，一共多少对象
可以在线定位，它 不会使系统卡顿

10.jmap导出堆转储文件
线上系统，内存特别大，jmap导出堆转储文件执行期间会对进程产生很大影响，甚至卡顿。万不可用，会导致系统瘫痪，解决方法：
设定参数HeapDumpOnOutOfMemoryError，OOM时自动产生堆转储文件
由于是集群部署，可以把出问题的服务器隔离，对他进行jmap导出，再观察 

022420







线上CPU100%、内存爆了解决思路：

top/jps查进程

jstack看线程排查死锁

若GC线程飚高，说明在频繁GC，应查看GC日志 ，用jmap看哪个对象占特别多，导出来分析