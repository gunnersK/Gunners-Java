* 程序计数器、虚拟机栈、本地方法栈这三个区域随线程而生、灭，所以他们的内存分配和回收都具备确定性，方法或线程结束时，内存自然也跟着回收了但是java堆只有在程序运行期间才知道创建哪些对象，内存分配和回收都是动态的，GC关注的就是这部分内存

# 一、对象存活判断（堆里的对象）
   1. 引用计数算法
      1. 当有一个地方引用这个对象，计数器就加1，引用失效就减1，当计数器为0，这个对象就不可能再被使用
      
      2. 但是java不用计数算法，因为不能解决对象之间相互循环引用的问题
   
   2. 根搜索算法
      1. 通过一系列的GC Roots对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的，会被判定是可回收对象。例如对象循环引用，但是他们到GC Roots不可达，所以可回收
      
      2. 可以做GC Roots的对象包括：
         1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
         
         2. 方法区中的类静态属性引用的对象
         
         3. 方法区中的常量引用的对象
         
         4. 本地方法栈中（Native方法）引用的对象
   
   3. 引用类型
      1. 强引用(Strong)--只要强引用还存在，GC永远不会回收掉这个对象。类似 Object obj = new Object() 
      
      2. 软引用(Soft)
      
      3. 弱引用(Weak)
      
      4. 虚引用(Phantom)
   4. 对象自救      
      1. finalize()方法
         1. GC在准备释放对象占用的存储空间时，首先调用finalize()方法
         
         2. 只是调用一下这个方法而已，回收对象的这个动作不在这个方法里，调不调用和回收对象没什么关系，就算不调用finalize()方法也可以回收对象
         
         3. 而且对象还可以通过这个方法自救
         
         4. 任何对象的finalize()方法只会被JVM调用一次
      
      2. 对象通过finalize()方法自救：
         重写finalize()方法，重新把自己(this)与引用链上的任何一个对象建立关联，比如把this赋值给某个类变量或对象的成员变量，这样被GC执行完finalize()方法之后，就不会被回收，还可以存活下来
      
      3. 如果对象进行根搜索后发现没有与GC Roots相连的引用链，那他会被第一次标记，并筛选判断是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()已经被JVM调用过，都被视为没必要执行
         1. 有必要执行（重写了finalize()方法或者没被JVM调用过）：对象会被放置在一个F-Queue队列中，稍后由一条低优先级的的Finalizer线程去执行，这时对象可以在finalize()方法里面通过重新赋值引用对象存活下来，联系第2点，那在第二次标记时它将被移出“即将回收”的集合。如果还没有被赋值给变量，那他接下来就会被回收了
         
         2. 没必要执行：没有覆盖finalize()方法，或者finalize()已经被JVM调用过就不会被执行，直接回收了
      
      4. 如果一个对象通过finalize()自救成功，那么下次回收对象，他的finalize()方法不会被再次执行，他就会被回收了     
      
      5. 不鼓励用重写finalize()方法来拯救对象，因为他运行代价高，不确定性大，无法保证各个对象调用顺序
      
# 二、垃圾收集算法  
   1. 标记-清除算法(Mark-Sweep)
      1. 原理：先标记出所有需要回收的对象，标记完后再统一回收掉
      
      2. 缺点
         1. 效率低，标记和清除过程的效率都不高
         
         2. 空间问题：会产生大量不连续的内存碎片，会导致分配大对象是无法找到足够的连续内存而提前触发另一次GC
         
      3. 是最基础的收集算法，后续的收集算法都是基于这种思路并对其缺点进行改进得到的
      
   2. 复制算法(Copying)      
      1. 原理：将可用内存五五开分两块，每次只使用其中的一块。当这一块内存用完，就把存活的对象复制到另一块上面，然后再把已经使用过的内存一次性清理掉。
      
      2. 优点：不会产生内存碎片，分配对象内存只需移动堆顶指针，按顺序分配内存，效率高
      
      3. 缺点：将内存缩小为原来的一半，代价高
      
      4. 改良(Minor GC)
         1. 新生代98%对象存活时间比较短，所以不需要1:1划分内存空间，而是将内存分为一块Eden+两块Survivor，默认比例是8:1:1
         
         2. 分配对象内存时只使用Eden和其中一块Survivor，回收是将这两块内存还存活的对象一次性拷贝到另一块Survivor，最后清理掉Eden和刚才用过的Survivor
         
         3. 默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%
         
         4. 当然没法保证每次回收都只有不多于10%的对象存活，这种算法会用老年代进行担保。
            如果Survivor空间不够存放上一次新生代存活下来的对象，就要直接通过分配担保机制进入老年代
         
   3. 标记-整理算法(Mark-Compact)
      1. 原理：标记过程和标记-清除算法一样，但后续步骤不是直接清理存活对象，而是把存活对象都向一端移动，然后直接清理掉端边界以外的内存
      
   4. 分代收集算法(Generational Collection)
      1. 原理
         1. 根据不同情况使用前面三个收集算法，并没有什么自己的新思想
         
         2. 根据对象存活周期一般将Java堆分为新生代和老年代，根据各个年代的特点使用最适当的收集算法
            1. 在新生代中，每次GC都有大批对象被回收，只有少量存活，就用复制算法
            
            2. 在老年代中，对象存活率高，没有额外空间对他进行分配担保，就用标记-清理或标记-整理算法

# 三、内存分配与回收策略

   1. 对象优先在Eden分配：当Eden不够空间分配内存时，就使用复制算法触发一次Minor GC(新生代GC)，清除掉无用对象，同时将存活对象移动到Survivor的其中一个区(fromspace区或者tospace区)。如果Survivor区放不下从Eden区过来的对象时，此时会使用分配担保机制将对象直接移动到年老代。
     
   2. 长期存活的对象将进入老年代：虚拟机是采用分代收集思想来管理内存，那内存回收时就必须能识别哪些对象应该放在新生代或老年代。虚拟机会给每个对象定义一个对象年龄(Age)计数器，对象在Survivor区中每熬过一次Minor GC，年龄就加1。待到年龄到达一定岁数(默认是15岁)，虚拟机就会将对象移动到老年代。
     
   3. 大对象直接进入老年代：如果大于虚拟机参数指定大小的对象，直接在分配到老年代
      
   4. Major GC
   
      1. Major GC的触发条件：Major GC又称为Full GC。当年老年代空间不够用的时候，虚拟机会使用“标记—清除”或者“标记—整理”算法清理出连续的内存空间，分配对象使用。
