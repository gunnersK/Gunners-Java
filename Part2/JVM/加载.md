## 类加载过程

#### 加载

调用ClassLoader的loadClass方法，将class文件中的字节码加载到JVM内存的方法区中形成二进制数据，在堆里形成class类对象并返回，class类对象指向这块内存（反射正是用class类对象去访问二进制代码）

- 通过一个类的全限定名来获取此类的二进制字节流
- 将字节流所代表的静态存储结构转化为运行时数据结构，按照虚拟机所需格式加载存储到方法区中
- 在Java堆实例化一个该类的class对象

字节码的来源可以有：硬盘、网络、数据库或jar包等

加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证）是交叉进行的，这些夹在加载阶段之中的动作仍然属于连接阶段的内容，此时加载阶段尚未完成



#### 连接

将方法区的二进制数据合并到JVM的运行状态之中（从静态数据变成运行时数据）

- **验证**：确保Class文件的字节流包含的信息符合虚拟机要求，且不会危害虚拟机

  包括：文件格式验证（CAFE BABE开头）、元数据验证、字节码验证、符号引用验证

- **准备**：静态变量方法区分配内存，设置默认值（零值）

  - 只对静态变量在方法区分配内存，实例变量在对象实例化时才分配

  - 静态变量初始值只是赋予默认值，只有final的static变量才会被赋予指定值

    例如：

    ```
    public static int a = 22;  
    a变量在准备阶段过后的初始值是0而不是22
    
    public static final int a = 22;  
    这时a变量在准备阶段就会被赋值为22了
    ```

  - 说明了为何引用类的final静态变量不会引发类的初始化，而引用static变量就会，因为final静态变量在初始化之前已经被赋值了

- **解析**：虚拟机将常量池内的符号引用替换为直接引用

  解析有时可以在初始化阶段之后开始，这是为了支持java的运行时绑定
  
  

#### 初始化

初始化是执行类构造器方法<clinit\>()方法的过程

把静态变量的赋**指定值**和静态代码块合并产生的就是类构造器方法
**注意**：静态变量的赋值动作和static块是按照代码位置先后的顺序执行的

初始化父类：当初始化一个类的时候，如果发现其父类还没有进行过初始化，会先初始化父类，所以JVM中第一个被执行<clinit\>()方法的类肯定是Object

<clinit\>()方法对于类或接口不是必须的，如果一个类中没有static块或没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit\>()方法

接口不能使用static块，但仍然有变量初始化的赋值操作，就会生成<clinit\>()方法，但是初始化接口, 不需要执行父接口的<clinit\>()方法，只有父接口定义的变量被使用才会执行

接口实现类初始化也不会执行接口的<clinit\>()方法

JVM会保证一个类的初始化方法在多线程的环境中被正确加锁和同步（线程安全）

只有第一次使用一个类时，才会执行该类的类构造器方法





## 类的主动引用和被动引用

#### 主动引用（被初始化）

被new出来

读取或设置一个类的static字段（final修饰的除外）

调用一个类的静态方法

第一次用反射的方法对类进行调用

初始化一个类时，如果发现其父类还没有进行初始化，需要先初始化父类

main方法所在类



#### 被动引用（不会被初始化）

子类引用父类的静态字段，不会初始化子类 

通过数组定义引用类    如：A1[] a = new A1[3]





## 双亲委派

#### 类加载器种类

- **Bootstrap ClassLoader（启动类加载器）**
  cpp实现，使用getClassLoader()方法获取会返回null，因为Java中没有与之对应的类
  加载核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等

- **Extention ClassLoader（扩展类加载器）**
  加载%JRE_HOME%\lib\ext目录下的jar包和class文件，或者被java.ext.dirs系统变量所指定的路径中的所有类库

- **Appclass Loader（应用程序类加载器）**
  加载当前应用的classpath（用户类路径）上指定的的所有类
  也称为SystemAppClass
  
- **Custom Loader（自定义类加载器）**
  继承ClassLoader类，重写findClass方法即可

  - 找到要load的二进制内容到内存
  - 再在defineClass方法(在ClassLoader类中)转化为class类对象就ok
  - 重写findClass方法就是模板方法设计模式的体现，留一部分功能给子类去实现（01:21:10）
  - 01:40:40

  写框架、类库都会用自定义ClassLoader，用来加载指定目录下的类
  
  
  

#### 双亲委派流程

每个类加载器都会先到自己的缓存拿，拿到就直接返回了，**不会重复加载**，拿不到就委托上一级父加载器加载，父加载器加载不了再委托上一级父加载器，直到Bootstrap，拿不到才会让子加载器加载，从下往上，再从上往下，绕一圈，是一个类似递归的过程，找不到类就抛ClassNotFoundException



#### 双亲委派的好处

保证java核心库的类型安全，有人写了类库同名的类，比如java.lang.String，也只能加载类库里的类，确保只有核心库里面的类才会被加载

提高效率，类被加载过一次就不会再重复加载了



#### 其他要点

多数JVM的实现都是懒加载，需要才加载类，一般不会把整个jar文件加载进来

类加载器的也需要类加载器加载进来，溯源到最后都是bootstrap加载器，类加载器之间虽然是父子关系，但他们是组合关系，不是继承关系

一个类被不同加载器加载，那他们就不==

方法区放从class文件加载进来的类，还有常量池。1.8之后方法区改名Metaspace（元数据空间）

“双亲委派”这个词用得不是很准确，因为他是一个从父到子、从子到父的过程

对某个值异或一次加密，再异或一次就解密了(str ^ seed)