#### JMM的含义看书归纳

- JMM主要内容：如何支持高并发场景，对象new出来之后在内存怎么布局

- DCL单例（双重检查锁）为什要加volatile：防止指令重排（093 -> 01:00:00），否则引发半初始化问题

#### 硬件相关知识

- 现代cpu数据一致性=缓存锁（MESI等协议实现）+总线锁
- 缓存行长度多数为64，无论是硬盘、内存还是cpu，读取数据都是按块读取，读取一个数据会顺便读取它相邻的数据。硬盘读硬盘块，内存读内存页，cpu读缓存行
- cpu以缓存行读取数据(按块读取思想)，intel缓存行容量64，两个核同时读取缓存行，一个修改数据会立即通知另一个核需要刷新缓存行最新的数据，这就是缓存一致性协议(MESI)。如果两个核同时修改同一个缓存行不同的数据，就会发生伪共享
- 位于同一缓存行的两个不同数据，被两个不同cpu锁定，产生相互影响的伪共享问题
  可以用缓存行对齐来提高效率，前后各补充56个字节，保证要取的数据不会跟别的数据在同一缓存行   

#### 乱序问题

乱序读：cpu为了提高指令执行效率，会在一条指令执行过程中（比如去内存读数据，速度慢100倍），去同时执行下一条指令，前提是两条指令么有依赖关系

乱序写：合并写技术
WCBuffer（write combining 合并写缓存），比L1还快，一般只有4个字节，当cpu计算完要把结果写回缓存时，由于缓存速度慢，跟不上cpu计算速度，cpu会把多条指令的计算结果合并保存在WCBuffer，最后写进缓存，而不是一条条写，这就是写操作的合并 
02:05:00再听一遍，挺乱

证明乱序的例子程序：02:20:00  

#### 有序性保障

内存屏障、lock汇编指令

JVM级别的有序性，硬件级别的实现并不一定依赖于硬件级别的内存屏障，还可以依赖于硬件级别的lock指令

#### 内存屏障（详细了解）

- 可用内存屏障保证指令不乱序，两条指令不可以重排
- 内存屏障有多个层级：cpu级别、硬件级别、JVM级别，不可混为一谈

- cpu级别的内存屏障：02:30:00 
  intel cpu内存屏障：sfence、lfence、mfence