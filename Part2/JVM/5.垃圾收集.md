**熟悉GC常用算法，熟悉常见垃圾收集器，具有实际JVM调优实战经验** 

## 对象存活判断

#### RC

引用计数算法，有一个地方引用这个对象，计数器加1，引用失效减1，当计数器为0，对象就不再被用

缺点：解决不了循环引用



#### Root Searching

根可达算法，通过一系列的GC Roots对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的，会被判定是可回收对象。例如对象循环引用，但是他们到GC Roots不可达，所以可回收

可做**GC Roots**的对象如下：

- JVM stack，虚拟机栈（栈帧中的本地变量表）中引用的对象
- static references in method，方法区中的类静态变量
- runtime constant pool，方法区中常量池引用的对象
- native method stack，本地方法引用的对象
- class类对象

程序启动之后马上需要的对象就是**根对象**

**110-0022**







## GC算法

#### Mark-Sweep（标记清除）

先标记出所有需要回收的对象，标记完后再统一回收掉

优点：算法简单，适用于存活对象较多的情况，清理过程效率较高

缺点：扫描两遍（第一遍找有用的对象，第二找没用的清除掉）扫描，算法本身效率偏低，会产生大量不连续内存碎片，会导致分配大对象是无法找到足够的连续内存而提前触发另一次GC



#### Copying（拷贝）

将可用内存五五开分两块，每次只使用其中的一块。当这一块内存用完，就把存活的对象复制到另一块上面，然后再把已经使用过的内存一次性清理掉。

优点：分配对象内存只需移动堆顶指针，按顺序分配内存，只扫描一次，不产生内存碎片，效率高，适用于存活对象较少的**Eden区**

缺点：空间代价高，需调整对象引用



#### Mark-Compact（标记整理）

标记过程和Mark-Sweep一样，但后续步骤是把存活对象都向一端移动，然后直接清理掉端边界以外的内存

优点：不会产生碎片，方便对象分配

缺点：扫描两次，需调整对象引用，效率低







## JVM内存分代模型

逻辑分区和物理分区的概念

- 新生代 + 老年代 + 永久代（1.7）/ 元数据区（1.8）

  新生代 : 老年代  1:3 / 1:2

  

- 新生代：Eden : Survivor : Survivor 8:1:1

  新生代空间耗尽触发**Minor GC/Young GC**，使用**Copying**算法

  将Eden区和S0区的对象进行一次Root Searching，找出活跃对象，复制到S1区，并将Eden区和S0区中的不可达对象清空，**交换S0与S1指针**

  若S1不足以容纳Eden和另一个S0中的存活对象，会使用**分配担保**机制将多余的对象将被移到老年代，称为**过早提升(Premature Promotion)**，导致老年代中短期存活对象的增长，可能会引发**严重的性能问题**

  ```
  问题来了，为什么Eden和S0S1是8:1:1 ?
  ```



- 老年代

  老年代空间耗尽触发**Major GC/Full GC**，新生代老年代同时回收



> JVM会给每个对象定义一个对象年龄(Age)计数器，记在对象头里，对象在Survivor区中每熬过一次Minor GC，年龄就加1。待到年龄到达一定岁数（默认是15岁，因为对象头只有4位用来保存对象当前年龄），虚拟机就会将对象移动到老年代。



#### 对象分配过程

<img src=".\pic\GC参数JVM.png" style="zoom:67%; float:left" />

​															（图1）



#### 动态年龄

https://www.jianshu.com/p/989d3b06a49d





 

## 对象分配流程

<img src=".\pic\对象分配流程.png" style="zoom: 67%; float: left" />

​																				（图2）

> new对象先判断能否栈上分配，能分配以后就不会被GC，对象直接出栈即释放内存
>
> 不能分配则判断是否大于虚拟机参数指定大小，超过了直接分配Old区
>
> 不是大对象则判断是否能进TLAB，不能就进Eden区（TLAB也在Eden区）
>
> 若Eden不够空间分配内存时，Eden进行一次Minor GC，将对象放进Eden
>
> 之后对象会被一次或多次Minor GC，会被移动到S0/S1/Old区，直到被GC掉



#### 什么对象会往栈上放？

线程私有小对象

无逃逸（只在特定代码块中有效，比如new出来没人引用他）

标量替换：可用基本类型代替的对象  （-XX:-/+EliminateAllocations)



#### 什么对象会往Eden分配？

线程本地分配TLAB（Thread Local Allocation Buffer）(-XX:-/+UseTLAB)

占用1%Eden，每个线程独有

多线程时不用竞争eden就可申请空间，提高效率

小对象





 

## 垃圾回收器

<img src=".\pic\常用垃圾回收器.png" style="zoom: 67%; float: left;" />



#### 垃圾回收器组合

Serial + Serial Old

ParNew + CMS

Parallel Scavenge + Paraller Old（PS+PO，JVM默认组合）

红线连的都能组合

左边6个逻辑上和物理上都分年轻代老年代，右边几个只逻辑上分年轻代老年代



> Serial追随JDK诞生，为了提高效率，诞生了PS，为了配合CMS，诞生了PN，CMS在1.4后期引入，是里程碑式的GC，开启了并发回收的过程，但是毛病较多，因此目前没有任何JDK版本默认CMS



#### Serial

stop-the-world（STW)   

单线程，**年轻代**串行回收，所有线程在safe point停止（比如还没unlock就等解锁之后再停止） 

单机CPU效率最高，现代计算机内存空间大，会导致此法停顿时间长，故极少用

  

#### Serial Old 

同**Serial**，用Mark-Sweep/Mark-Compact算法，在**老年代**清理



#### Parallel Scavenge

多线程**年轻代**回收



#### Parallel Old

多线程**老年代**回收，使用Mark-Compact   



#### ParNew（Parallel New）

**年轻代**并行回收

Parallel Scavenge的变种，对Parallel Scavenge进行增强，以便更好地和CMS配合使用



#### CMS（Concurrent Mark Sweep）

**老年代**垃圾回收器

随着服务器内存变大，Serial和Parallel清理的耗时变得无法忍受

诞生了CMS，这是**里程碑式的GC，开启了并发回收的过程**，即工作线程和垃圾回收线程同时进行

Parallel是**并行**回收，多个线程同时回收

CMS是 回收的同时还可以产生新垃圾

##### CMS清理过程

- 初始标记（STW）

  标记GC Roots

- 并发标记

  80%的时间都用在这里，和工作线程同时进行

- 重新标记（STW）

  重新标 记并发标记时新产生的少量垃圾、以及被并发标记过但现在又不是垃圾的对象

- 并发清理

  并发清理产生的新垃圾称为浮动垃圾，等下一次CMS清理

##### CMS的问题

- 内存碎片

  当产生大量内存碎片，CMS清理不过来时，会动用Serial Old回收，极其耗时

  **0022再看一遍**

- 浮动垃圾

  保持老年代有足够空间，可通过调整-XX:CMSInitiatingOccupancyFraction参数（默认92%）降低触发CMS的阈值，要注意调太低也会浪费内存



垃圾收集器跟内存大小的关系

Serial：几十兆

PS：上百兆-几个G

CMS：20G

G1：上百G

ZGC：4T





- -XX和-X的区别 在110-0229