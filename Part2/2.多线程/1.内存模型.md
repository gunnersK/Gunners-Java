- CPU与内存速度差异太大，引入cache，导致可见性（数据一致性）的问题
- 为了压榨CPU性能，引入多线程并发处理，导致原子性（线程安全）问题
  - 单核的多线程用的都是同一份cache，不会引发线程安全问题
  - 多核多线程就会导致数据不一致的线程安全问题
  - 加了锁也不是原子性，只有CPU原语级别的指令才会保证原子性不被中断
- 为了提高程序执行性能，引入执行乱序执行处理，导致有序性问题





## 硬件工作效率

- 为了充分利用CPU性能，会让CPU分时间片并发执行计算任务

- 但是多数运算任务不止是简单的处理器计算就能完成，还要与内存交互

  但是内存的速度与CPU差了好几个数量级，所以为了解决CPU与内存速度差异过大问题，引入三级cache

- 有了三级cache之后，为了充分利用CPU内部的运算单元，会对指令乱序执行处理，进行处理器优化







## 并发编程的问题

正是由于以上三个提高硬件工作效率的措施，在并发编程中会导致数据一致(可见)性、原子性、有序性问题

##### 数据一致性

CPU的三级cache，会导致主内存的变量值在不同核心的cache中不一致，引发并发编程时数据不一致

##### 原子性

若代码指令没执行完，时间片就用完了，操作被迫中断，导致操作不原子

##### 有序性

指令乱序执行，会导致程序运行后得出非预期结果







## 并发问题的解决

#### 硬件层面

- 数据一致性

  > 缓存锁、总线锁、MESI等数据一致性协议
  >
  > 这里为了充分利用处理器内部运算单元，可能会进行指令乱序执行，引发有序性问题

- 有序性

  > 内存屏障



由于不同CPU实现的架构不一样，对各种并发问题的解决手段不一样，为了屏蔽底层硬件和OS对内存的访问差异

JVM定义了内存模型的规范，抽象出内存模型的概念，在不同硬件架构平台上的虚拟机对内存模型有不同的实现

保证Java并发程序在不同的平台上运行、对内存的访问都能得出相同的结果

C/C++是直接使用处理器和OS的内存模型，所以有可能在一个平台正常运行的程序到另一个平台运行就出错，所以写C/C++程序时，需要我们去关注和处理平台间的差异带来的并发问题

而Java因为有了内存模型，屏蔽掉不同平台底层解决并发问题的手段，使得进行并发编程时可以只关注业务的本身，而无需去关心如何解决底层并发问题



#### JVM层面

- 数据一致(可见)性

  > volatile

- 有序性

  > JVM内存屏障

- 原子性

  > 锁