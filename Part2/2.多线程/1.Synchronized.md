## 对象监视器monitor

每个对象（包括class对象）都会关联一个monitor，monitor中有一个初始值为0的计数器

字节码层面会用monitorenter和monitorexit两条指令代表加锁和释放锁

一个线程要获取对象的锁，执行monitorenter指令时，需要先看monitor计数器是不是0，0就可以获取锁，然后计数器 +1

而且支持重入，即当前线程第二次获取对象的锁，会把计数器+1，+2，+3....

线程在代码段执行结束会对计数器 -1

若其他线程判断到对象monitor的计数器大于0，则会阻塞等待获取锁









## 锁升级

https://blog.csdn.net/lkforce/article/details/81128115

<img src=".\pic\Mark Word.jpg" style="zoom: 67%; float:left" />

- 偏向锁

  - 当线程A发现对象处于无锁状态（Mark Word锁标志位是001），则进行CAS抢锁
    - 抢到了就将线程ID设为自己的，把对象设为偏向锁状态
    - 抢不到代表有竞争，升级为轻量级锁
  - 当线程A给对象上了偏向锁
    - 如果现在是线程A再次尝试获取锁，会发现对象处于偏向锁状态且线程ID是自己的线程，现在是锁重入，可执行临界代码
    - 如果现在是线程B尝试获取锁，会发现对象处于偏向锁状态且若线程ID不是自己的线程，则进行CAS抢锁，这里是有可能成功的，因为线程A释放锁后不会把线程ID删掉，不会释放锁`这里还不太确定，要搞明白`。线程B抢成功了就设为偏向锁，抢不到代表有竞争，升级为轻量级锁

- 轻量级锁

  当偏向锁抢锁失败，升级为轻量级锁（Mark Word锁标志位是101）

  会在当前线程栈开辟空间，称为Lock Record，保存Mark Word的副本地址；然后在Mark Word中保存Lock Record空间的指针

  上述两个保存操作都是CAS操作，保存成功代表成功上锁，Mark Word锁标志位设为00，保存失败则进行自旋重试保存操作

  重试次数默认10次，10次依然失败，则升级重量级锁

- 重量级锁

  Mark Word锁标志位设为10，未抢到锁的线程都进入等待队列阻塞

  重量级锁需要阻塞和唤醒线程，有系统调用，用户态切换到内核态，有可能切换状态的时间比执行用户代码的时间还长，所以是操作是重量级

  共享数据的锁定状态一般只会持续很短的一段时间，在整个同步周期内都是不存在竞争的，为了这段时间去挂起和恢复线程其实并不值得

- 加锁代码执行时间短、等待线程少，用自旋锁

  因为如果线程过多，CPU需要在多个线程之间进行切换，会消耗很多时间在上下文切换上
  
  如果代码执行时间长，会使CPU一直在空转，浪费CPU资源，降低性能
  
  执行时间长，线程多，用系统锁

因为有锁升级的过程，所以Synchronized性能未必比其他锁差

`synchronized锁原理这块还没完全搞清楚，monitor和对象头锁信息的关系？`









## 锁粗化

程序多个小的代码块加锁，频繁加锁解锁会增加不必要的开销，JVM可能会优化为对整个大的代码块只加一个锁，这就是锁粗化









## 锁消除

JVM识别到某段代码不会造成线程不安全但却加了锁，比如对sout加锁，就会把锁去掉，这就是锁消除







