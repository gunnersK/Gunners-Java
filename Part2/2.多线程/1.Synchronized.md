- 字节码层面会用monitorenter和monitorexit两条指令代表加锁和释放锁

- 每个对象（包括class对象）都会关联一个monitor，monitor中有一个初始值为0的计数器

  `从硬件层面了解下`

  一个线程要获取对象的锁，执行monitorenter指令时，需要先看monitor计数器是不是0，0就可以获取锁，然后计数器 +1

  而且支持重入，即当前线程第二次获取对象的锁，会把计数器+1，+2，+3....

  线程在代码段执行结束会对计数器 -1

  若其他线程判断到对象monitor的计数器大于0，则会阻塞等待获取锁

#### 锁升级

- 偏向锁

  先在对象头记当前线程id，不加锁，下次若还是这个线程来访问就直接给他，若有别的线程来了就升级自旋锁

- 自旋锁

  自旋判断锁是否被释放，会消耗cpu，自旋10次（默认）之后升级重量级锁，向OS申请资源，线程进入等待队列wait

- 加锁代码执行时间短、等待线程少，用自旋锁。执行时间长，线程多，用系统锁

因为有锁升级的过程，所以Synchronized性能未必比其他锁差

`synchronized锁原理这块还没完全搞清楚，monitor和对象头锁信息的关系？`

