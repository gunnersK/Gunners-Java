- 字节码层面会用monitorenter和monitorexit两条指令代表加锁和释放锁

- 每个对象（包括class对象）都会关联一个monitor，monitor中有一个初始值为0的计数器

  `从硬件层面了解下`

  一个线程要获取对象的锁，执行monitorenter指令时，需要先看monitor计数器是不是0，0就可以获取锁，然后计数器 +1

  而且支持重入，即当前线程第二次获取对象的锁，会把计数器+1，+2，+3....

  线程在代码段执行结束会对计数器 -1

  若其他线程判断到对象monitor的计数器大于0，则会阻塞等待获取锁

#### 锁升级

- 偏向锁

  第一个获取锁对象的线程，先在对象头记当前线程id，不加锁，下次若还是这个线程来访问就直接给他，若有别的线程来了就升级自旋锁

- 自旋锁

  自旋判断锁是否被释放，会消耗cpu，自旋10次（默认）之后升级重量级锁，向OS申请资源，线程进入等待队列wait

  当尝试线程获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS  操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态

- 重量级锁

  共享数据的锁定状态一般只会持续很短的一段时间，在整个同步周期内都是不存在竞争的，为了这段时间去挂起和恢复线程其实并不值得

  而且需要阻塞和唤醒线程，所以要系统调用，有用户态内核态的切换，有可能切换状态的时间比执行用户代码的时间还长，所以是重量级锁

- 加锁代码执行时间短、等待线程少，用自旋锁

  因为如果线程过多，CPU需要在多个线程之间进行切换，会消耗很多时间在上下文切换上
  
  如果代码执行时间长，会使CPU一直在空转，浪费CPU资源，降低性能
  
  执行时间长，线程多，用系统锁

因为有锁升级的过程，所以Synchronized性能未必比其他锁差

`synchronized锁原理这块还没完全搞清楚，monitor和对象头锁信息的关系？`



#### 锁粗化

程序多个小的代码块加锁，频繁加锁解锁会增加不必要的开销，JVM可能会优化为对整个大的代码块只加一个锁，这就是锁粗化



#### 锁消除

JVM识别到某段代码不会造成线程不安全但却加了锁，比如对sout加锁，就会把锁去掉，这就是锁消除



多线程抢锁下锁升级流程以及对象头内容演变过程还没搞懂

https://blog.csdn.net/lkforce/article/details/81128115





