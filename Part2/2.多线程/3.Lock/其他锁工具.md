## CountDownLatch 







## CyclicBarrier

线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行，即线程必须等所有线程齐了才可以继续跑

```java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(10);
    for (int i = 0; i < 11; i++) {
        new Thread( () -> {
            try {
                System.out.println("上车");
                cyclicBarrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
            System.out.println("出发");
        }).start();
    }
}
```







## Semaphore

信号量

应用场景：限流，类似于车道和收费站（8个车道，2个收费站，一次只能过2辆车）

```java
public static void main(String[] args) {
//  Semaphore semaphore = new Semaphore(1);
    Semaphore semaphore = new Semaphore(1, true); // true指定为公平

    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T1 running");
            Thread.sleep(1000);
            System.out.println("T1 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T2 running");
            Thread.sleep(1000);
            System.out.println("T2 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
}
```







## Exchanger

两个线程两两交换







## LockSupport

park() -- 阻塞当前线程

unpark(Thread t) -- 线程继续运行

unpark可以先于park调用，一旦先调用unpark，再调用park线程就不会阻塞了







## Condition

Lock.newCondition

await/signal/signalAll

类比wait/notify/notifyAll

本质就是等待队列



```
wait/notify/notifyAll
await/signal/signalAll
park/unpark
归纳整理

LockSupport
Condition
生产者消费者题Condition版
AQS原理
```







## ThreadLocal

每个线程对象（Thread）内部会维护一个map，key是ThreadLocal对象（this），value是set进去的值

用于spring声明式事务







## 强软弱虚

软引用：内存不够时会回收掉软引用，做缓存用

弱引用：只要遭遇GC就会被回收，用在容器里（ThreadLocal -> WeakHashMap）

只要指向他的强引用消失了他就该被回收

虚引用：虚引用指向堆外内存，当虚引用被回收时，会放进指定的队列中，可以通过监听队列中的引用来回收堆外内存（非JVM管）的对象，操作堆外内存才用得到，比如写Netty和JVM







## 锁分类

乐观锁：CAS

悲观锁：Synchronized

自旋锁

读写锁

分段锁：LongAdder、ConrrentHashMap







