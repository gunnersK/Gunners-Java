- queue主要为高并发准备

- Vector类是线程安全的 

- 多线程环境下，少考虑List，多考虑Queue

- ConcurrentHashMap特点：读效率高，写效率并不高，比HashTable还低

- 不是ConcurrentHashMap就可以替代SynchronizedHashMap，根本原因还是CAS不一定比Synchronized效率高，他们不是替代关系，要根据并发量高低、原子代码的执行时间来看待，根据实际情况来灵活选用哪种容器

  任何情况下都需要用压测来决定使用何种容器

- LinkedHashMap、TreeMap（红黑树）了解下



#### ConcurrentSkipListMap

并发 排序map，因为多线程环境下树结构用CAS实现排序较困难，所以没有ConcurrentTreeMap

跳表实现，底层还是链表，往上一层层加链表关键节点索引，越往上链表节点越少，类似二分查找

![](D:\Learning\Gunners-Java\Part2\2.多线程\pic\跳表结构.png)



#### CopyOnWriteList

写时复制，写时复制原数组，然后加锁写，读不用加锁，适用于读多写少场景



#### Queue 

用CAS实现原子性

ConcurrentLinkedQueue无界队列

Queue的offer、poll、peek都不是阻塞方法，offer队列满了或poll、peek队列为空报异常，用CAS实现原子性

BlockingQueue：在Queue的基础上添加了put、take方法，俩方法真正实现了阻塞，put队列满了或take队列为空时线程会阻塞住
阻塞实现原理都是用locksupport的park方法（使线程进入阻塞状态）
自然地实现任务队列，适用**生产者消费者模型** （该模型是多线程最重要的模型）

LinkedBlockingQueue：无界

ArrayBlockingQueue：有界

**Queue和List的区别？**

Queue提供了对线程友好的api：offer、poll、peek。以及BlockingQueue的put、take实现阻塞



#### 其他BlockingQueue

DelayQueue：按照等待的时间进行排序，等待时间越短越先出队，而不是按顺序出队，要求任务必须继承Delayed类，重写compare方法自定义比较逻辑来自定义出队顺序，可用来实现按时间进行任务调度，本质上是PriorityQueue   

DelayQueue自定义排序是不是就不用PriorityQueue排序了，蒙

PriorityQueue用小根堆实现排序

SynchronusQueue：队列容量为0，用来实现一个线程给另一线程传递数据

六0223