## AQS

学这块要看源码

#### 定义

AbstractQueuedSynchronizer  抽象队列同步器，基于模板模式的**锁框架**，供各种子类去实现



#### 原理

##### acquire

独占锁获取同步状态

> !tryAcquire() -- 尝试获取同步状态，即获取state变量
>
> 若同步状态获取失败，调用addWaiter()方法构造Node，以CAS的形式插到同步队列队尾
>
> 再调用acquireQueued()死循环判断前驱节点是否队头元素，是就继续tryAcquire()，获取同步状态
>
> 若前驱节点非队头元素或获取同步状态失败，则调用LockSupport.park()阻塞当前线程
>
> 直到前驱节点出队将其唤醒，或阻塞线程被中断将其唤醒 `中断唤醒这里不理解`

<img src="D:\Learning\Gunners-Java\Part2\2.多线程\pic\AQS框架原理.jpg" style="zoom:80%; float:left" />

内部主要有state变量、等待队列、加锁线程变量

当锁被某个线程持有，修改state值，修改state是CAS操作，加锁线程变量值改成自己

当锁被释放，再修改state值，同时唤醒队头的线程

当线程尝试CAS修改state获取锁时，若获取不了，会把自己挂起，进入等待队列

**进入等待队列的过程也是CAS过程**，防止一个节点后面挂好多个节点，导致线程不安全。入队前先保存tail节点，执行CAS操作时判断当前tail节点跟之前保存的tail节点是否一致

在无竞争的状态下，队头head不会被初始化



##### tryAcquire

独占锁获取同步状态，模板方法，AQS的子类有不同的实现



##### release

独占锁释放同步状态，LockSupport.unpark(s.thread)唤醒队头的下一个线程



#### 组成

##### state

volatile类型，初始值为0，具体作用和用法由子类实现去定义

例如ReentrantLock实现：0解锁状态，每获取一次锁state +1（**可重入**）

CountDownLatch实现：设置state初始值为x，每次 -1直到0



##### 等待队列

双向链表，每个node保存的是线程

双向是因为加入队列添加节点时需要考虑前面节点的状态，如果前面节点正在持有线程，新节点就排在他后面，若前面节点被取消了就应该越过前面的节点

`还不是很理解双向的原因`



##### VarHandle（变量句柄）

对于某块地址空间的值，可绕过指向他的变量直接指向这块地址空间，可对里面的值进行原子操作，即对普通属性的原子操作

直接操作二进制码，效率比反射高

`深入了解VarHandle和反射`



#### 自定义同步组件

实现Lock类，声明静态内部类继承AQS

锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承AQS就可以很好的隔离二者所关注的事情







## ReentrantLock

#### 内部结构

基于AQS实现

有一个抽象静态内部类Sync，继承AQS

有两个静态内部类FairSync和NonfairSync，继承Sync，重写AQS的tryAcquire()方法，实现公平锁与非公平锁



#### 公平锁原理

每个线程调用tryAcquire()获取同步状态时

会先调用hasQueuedPredecessors()方法判断当前同步队列中有没有比自己先进入等待状态的线程

有他只能进入等待队列排队，直到被唤醒

没有就直接CAS设置state变量



#### 非公平锁原理

非公平锁的tryAcquire()方法获取同步状态时，少了公平锁hasQueuedPredecessors()的判断

Q：那么非公平锁不就和AQS同步队列FIFO性质冲突了吗？

A：有以下非公平情景：

> t1线程释放锁，唤醒队头t2线程，调用tryAcquire()尝试获取同步状态
>
> 这时来了t3线程，也调用tryAcquire()尝试获取同步状态
>
> 注意，此时t2和t3调用的是同一段代码，即NonfairSync重写AQS的tryAcquire()方法
>
> 就会导致两个线程同时尝试修改同步状态
>
> 若t2还没成功获取锁时，t3成功把锁抢了，t2只能接着在队列等待，就导致了不公平
>
> 所以这里的不公平针对的是同步队列中被唤醒的线程与未加入同步队列第一次tryAcquire()的线程
>
> 若t3抢锁失败，还是会到同步队列中排队，所以对于同步队列内部的线程还是公平的

ReentrantLock(boolean fair)带布尔值的构造函数可用来指定是否用公平锁

*公平锁为了保证公平需要进行大量的线程切换 `不是很理解`，非公平锁会造成线程饥饿，但却保证了更高的吞吐量* 



#### 锁重入原理

ReentrantLock的FairSync和NonfairSync重写AQS的tryAcquire()方法中有这段逻辑

```java
else if (current == getExclusiveOwnerThread()) {
    int nextc = c + acquires;
    if (nextc < 0)
        throw new Error("Maximum lock count exceeded");
    setState(nextc);
    return true;
}
```

current == getExclusiveOwnerThread()  判断独占锁是否被当前线程持有

是就把state变量加1，同一个线程多次获得锁不用阻塞等待，即可重入



#### tryLock原理

- tryLock() 

  不指定等待时间，直接调用NonfairSync的nonfairTryAcquire()方法，非公平操作

- tryLock(long timeout, TimeUnit unit)

  指定等待时间，调用抽象静态内部类Sync的tryAcquireNanos()方法

  接下来在整体上就是走了AQS的acquire()逻辑（看上面流程图），只不过多了等待时间判断

  在tryAcquire()失败加入同步队列之前，会根据当前时间 + 指定的等待时间，算出等待超时时间

  加入同步队列之后，就进入死循环操作

  若前一个节点不是头结点，会判断当前是否超出等待时间，是就返回加锁失败，否就调用LockSupport.parkNanos()方法阻塞，这里会指定最大阻塞时间

  若前一个节点是头结点，死循环自旋tryAcquire()操作，也会判断当前是否超出等待时间

  

#### lockInterruptibly







## ReadWriteLock

读锁 -> 共享锁

写锁 -> 排它锁

```java
static void read(Lock lock) {
    try {
        lock.lock();
        Thread.sleep(1000);
        System.out.println("read over");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

static void write(Lock lock) {
    try {
        lock.lock();
        Thread.sleep(1000);
        System.out.println("write over");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

public static void main(String[] args) {
    ReentrantLock reentrantLock = new ReentrantLock();
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    for (int i = 0; i < 10; i++) new Thread( () -> read(readLock)).start();
    for (int i = 0; i < 2; i++) new Thread( () -> write(writeLock)).start();
}
```

​      





## CountDownLatch 







## CyclicBarrier

线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行，即线程必须等所有线程齐了才可以继续跑

```java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(10);
    for (int i = 0; i < 11; i++) {
        new Thread( () -> {
            try {
                System.out.println("上车");
                cyclicBarrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
            System.out.println("出发");
        }).start();
    }
}
```







## Semaphore

信号量

应用场景：限流，类似于车道和收费站（8个车道，2个收费站，一次只能过2辆车）

```java
public static void main(String[] args) {
//  Semaphore semaphore = new Semaphore(1);
    Semaphore semaphore = new Semaphore(1, true); // true指定为公平

    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T1 running");
            Thread.sleep(1000);
            System.out.println("T1 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T2 running");
            Thread.sleep(1000);
            System.out.println("T2 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
}
```







## Exchanger

两个线程两两交换







## LockSupport

park() -- 阻塞当前线程

unpark(Thread t) -- 线程继续运行

unpark可以先于park调用，一旦先调用unpark，再调用park线程就不会阻塞了







## Condition

Lock.newCondition

await/signal/signalAll

类比wait/notify/notifyAll

本质就是等待队列



```
wait/notify/notifyAll
await/signal/signalAll
park/unpark
归纳整理

LockSupport
Condition
生产者消费者题Condition版
AQS原理
```







## ThreadLocal

每个线程对象（Thread）内部会维护一个map，key是ThreadLocal对象（this），value是set进去的值

用于spring声明式事务







## 强软弱虚

软引用：内存不够时会回收掉软引用，做缓存用

弱引用：只要遭遇GC就会被回收，用在容器里（ThreadLocal -> WeakHashMap）

只要指向他的强引用消失了他就该被回收

虚引用：虚引用指向堆外内存，当虚引用被回收时，会放进指定的队列中，可以通过监听队列中的引用来回收堆外内存（非JVM管）的对象，操作堆外内存才用得到，比如写Netty和JVM







## 锁分类

乐观锁：CAS

悲观锁：Synchronized

自旋锁

读写锁

分段锁：LongAdder、ConrrentHashMap







