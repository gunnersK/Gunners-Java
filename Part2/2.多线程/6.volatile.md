## 内存模型

每个线程都有自己的一个内存区域，然后多个线程跟主内存进行交互，对象也放在主内存里面，每个线程都有一个缓存区，线程操作主内存的对象中的变量时，是把变量从主内存拷贝一份放到自己的缓存区进行修改，改完了再写回去主内存







## 指令重排

编译器、指令器可能对代码重排序，但如果满足happens-before原则，就不能指令重排

##### happens-before原则

- **程序次序规则**：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

- **锁定规则**：一个unLock操作先行发生于后面对同一个锁的lock操作，比如说在代码里有先对一个lock.lock()，lock.unlock()，lock.lock()

- **volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个volatile变量的读操作，volatile变量写，再是读，必须保证是先写，再读

- **传递规则**：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

- **线程启动规则**：Thread对象的start()方法先行发生于此线程的每个一个动作，thread.start()，thread.interrupt()

- **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

- **线程终结规则**：线程中所有的操作都先行发生于线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行

- **对象终结规则**：一个对象的初始化完成先行发生于他的finalize()方法的开始







## volatile

#### 禁止指令重排序

原理见1.JVM -> 3.Java内存模型  通过内存屏障来保证指令有序性



#### 保证可见性

当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值

##### 原理

对volatile变量`a`执行写操作时，JVM会发送一条**lock前缀指令**给CPU，CPU在计算完之后会立即将值写回主内存，同时因为有MESI缓存一致性协议，各个CPU都会对总线进行嗅探，判断自己本地缓存中的数据是否被修改。如果发现别人修改了某个缓存的数据，那CPU就会将自己本地缓存的数据过期掉，然后这个CPU上执行的线程在读取变量`a`的时候，就会从主内存重新加载最新的数据了

代码case：

```java
   public class T {
    /*volatile*/ boolean flag = true;

    void m(){
      while(flag){}
      System.out.println("end");
    }

    public static void main(String[] args) {
      final T t = new T();
      new Thread(new Runnable(){
        @Override
        public void run() {
          t.m();
        }
      }).start();
      try {
        Thread.sleep(10);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      t.flag = false;
    }
  }
```

**解析**：

main方法里起一个线程a执行m()方法，这个线程先把flag从主内存读到缓存区中，然后判断flag，因为这时候flag==true，所以是死循环，这种情况下cpu很忙，腾不出时间来从主内存获取最新的flag的值，所以当main线程把t.flag更新为false时，那个线程没有从主内存获取最新的flag，一直还是用那个最初的flag值去判断，就跳不出循环，线程就不能结束了

**若使用volatile**：修改flag时会**强制**将修改的值立即写入**主存**

在线程main修改flag值时，包括2个操作，修改main线程工作内存中的值，然后将修改后的值写入主存，这样的修改会使得线程a的工作内存中缓存变量flag的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效），然后线程a读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。







## volatile和Synchronized的区别

Synchronized既保证可见性，又保证原子性；而volatile只保证可见性，不能保证多个线程共同修改变量时所带来的不一致问题，不能代替Synchronized

Synchronized效率比volatile低，所以只需要保证可见性的时候就不要用synchronized

##### volatile不能保证原子性的例子

> 两个线程操作volatile变量v，线程a拿到变量v给加到10，刷进主存，线程b开始运行，这时它在主存拿到v，拷贝到缓存区，v的值是10，然后给他加到20，然后写回去，但是在他写回去主内存之前，线程a已经把v加到30，也已经写到主内存了，这时线程b把v(值是20)写进主内存的时候就会把30覆盖掉，因为：
>
> 1. 线程b从缓存区读取v的动作发生在线程a把v=30更新进主存之前，所以不会导致他的缓存行失效，所以线程b就直接在缓存区拿v了，加到20再写主存
>
> 2. 写进主存时是不会判断主内存中v的值还是不是最初他从主内存中拿v时候的值的，所以说volatile只能保证可见性，不能保证原子性
>
> 3. **总结：** 在一个线程尚未完成把修改的volatile变量 **更新进主存之前**，另一个线程**已经获得**该volatile变量的值，并且做出修改，那就会出现不能保证原子性的情况
>
> 4. 这种情况就要使用Synchronized了，先让线程a把v加完到30，线程b再操作



