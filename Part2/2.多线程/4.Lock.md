## AQS

#### 定义

AbstractQueuedSynchronizer  抽象队列同步器，基于模板模式的锁框架，供各种子类去实现

#### 原理

内部主要有state变量、等待队列、加锁线程变量

当锁被某个线程持有，修改state值，修改state是CAS操作，加锁线程变量值改成自己

当锁被释放，再修改state值，同时唤醒队头的线程

当线程尝试CAS修改state获取锁时，若获取不了，会把自己挂起，进入等待队列

**进入等待队列的过程也是CAS过程**，防止一个节点后面挂好多个节点，导致线程不安全

##### state

volatile类型，初始值为0，具体作用和用法由子类实现去定义

例如ReentrantLock实现：0解锁状态，每获取一次锁state +1（**可重入**）

CountDownLatch实现：设置state初始值为x，每次 -1直到0

##### 等待队列

双向链表，每个node保存的是线程



锁基本都用AQS，所以用的都是CAS，而Synchronized不用CAS





## ReentrantLock

基于AQS实现

#### 非公平锁

当t1线程释放锁，唤醒队头t2线程，t2线程还没成功获取锁时，t3线程进来把锁抢了，t2线程只能再次进入队列等待，这是非公平锁

#### 公平锁

每个线程只能进入等待队列排队，直到被唤醒才能获取锁

ReentrantLock(boolean fair)带布尔值的构造函数可用来指定是否用公平锁

`了解下公平非公平如何实现`

`了解锁重入原理`

#### tryLock

#### lockInterruptibly      

#### ReentrantLock和Synchronized的区别

ReentrantLock底层用cas实现，sync有锁升级的过程

#### CountDownLatch 

#### CyclicBarrier

线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行，即线程必须等所有线程齐了才可以继续跑

```java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(10);
    for (int i = 0; i < 11; i++) {
        new Thread( () -> {
            try {
                System.out.println("上车");
                cyclicBarrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
            System.out.println("出发");
        }).start();
    }
}
```



#### ReadWriteLock

读锁 -> 共享锁

写锁 -> 排它锁

```java
static void read(Lock lock) {
    try {
        lock.lock();
        Thread.sleep(1000);
        System.out.println("read over");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

static void write(Lock lock) {
    try {
        lock.lock();
        Thread.sleep(1000);
        System.out.println("write over");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

public static void main(String[] args) {
    ReentrantLock reentrantLock = new ReentrantLock();
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    for (int i = 0; i < 10; i++) new Thread( () -> read(readLock)).start();
    for (int i = 0; i < 2; i++) new Thread( () -> write(writeLock)).start();
}
```



#### Semaphore

信号量

应用场景：限流，类似于车道和收费站（8个车道，2个收费站，一次只能过2辆车）

```java
public static void main(String[] args) {
//  Semaphore semaphore = new Semaphore(1);
    Semaphore semaphore = new Semaphore(1, true); // 可指定是否公平

    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T1 running");
            Thread.sleep(1000);
            System.out.println("T1 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T2 running");
            Thread.sleep(1000);
            System.out.println("T2 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
}
```



#### Exchanger

两个线程两两交换



#### LockSupport

park() -- 线程阻塞

unpark() -- 线程继续运行

unpark可以先于park调用，一旦先调用unpark，再调用park线程就不会阻塞了



#### Condition

Lock.newCondition

await/signal/signalAll

类比wait/notify/notifyAll

本质就是等待队列



```
wait/notify/notifyAll
await/signal/signalAll
park/unpark
归纳整理

LockSupport
Condition
生产者消费者题Condition版
AQS原理
```





## 锁分类

乐观锁：CAS

悲观锁：Synchronized

自旋锁

读写锁

分段锁：LongAdder、ConrrentHashMap