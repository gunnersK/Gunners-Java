## AQS

#### 定义

AbstractQueuedSynchronizer  抽象队列同步器，基于模板模式的锁框架，供各种子类去实现

#### 原理

内部主要有state变量、等待队列、加锁线程变量

当锁被某个线程持有，修改state值，修改state是CAS操作，加锁线程变量值改成自己

当锁被释放，再修改state值，同时唤醒队头的线程

当线程尝试CAS修改state获取锁时，若获取不了，会把自己挂起，进入等待队列

**进入等待队列的过程也是CAS过程**，防止一个节点后面挂好多个节点，导致线程不安全。入队前先保存tail节点，执行CAS操作时判断当前tail节点跟之前保存的tail节点是否一致

##### state

volatile类型，初始值为0，具体作用和用法由子类实现去定义

例如ReentrantLock实现：0解锁状态，每获取一次锁state +1（**可重入**）

CountDownLatch实现：设置state初始值为x，每次 -1直到0

##### 等待队列

双向链表，每个node保存的是线程

双向是因为加入队列添加节点时需要考虑前面节点的状态，如果前面节点正在持有线程，新节点就排在他后面，若前面节点被取消了就应该越过前面的节点

`还不是很理解双向的原因`

##### VarHandle（变量句柄）

对于某块地址空间的值，可绕过指向他的变量直接指向这块地址空间，可对里面的值进行原子操作，即对普通属性的原子操作

直接操作二进制码，效率比反射高

`深入了解VarHandle和反射`



锁基本都用AQS，所以用的都是CAS，而Synchronized不用CAS



#### 自定义同步组件

实现Lock类，声明静态内部类继承AQS

锁面向的是使用用户,而同步器面向的则是线程控制,那么在锁的实现中聚合同步器而不是直接继承AQS就可以很好的隔离二者所关注的事情



#### 调用AQS的acquire()获取同步状态

!tryAcquire() -- 尝试获取同步状态，即获取state变量

若同步状态获取失败，调用addWaiter()方法构造Node，以CAS的形式插到同步队列队尾

再调用acquireQueued()死循环判断前驱节点是否队头元素，是就继续tryAcquire()，获取同步状态

若前驱节点非队头元素或获取同步状态失败，则调用LockSupport.park()阻塞当前线程

直到前驱节点出队将其唤醒，或阻塞线程被中断将其唤醒 `中断唤醒这里不理解`



## ReentrantLock

基于AQS实现

#### 非公平锁

当t1线程释放锁，唤醒队头t2线程，t2线程还没成功获取锁时，t3线程进来把锁抢了，t2线程只能再次进入队列等待，这是非公平锁

#### 公平锁

每个线程只能进入等待队列排队，直到被唤醒才能获取锁

ReentrantLock(boolean fair)带布尔值的构造函数可用来指定是否用公平锁

`了解下公平非公平如何实现`

`了解锁重入原理`

#### tryLock

#### lockInterruptibly      

#### ReentrantLock和Synchronized的区别

ReentrantLock底层用cas实现，sync有锁升级的过程

#### CountDownLatch 

#### CyclicBarrier

线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行，即线程必须等所有线程齐了才可以继续跑

```java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(10);
    for (int i = 0; i < 11; i++) {
        new Thread( () -> {
            try {
                System.out.println("上车");
                cyclicBarrier.await();
            } catch (InterruptedException | BrokenBarrierException e) {
                e.printStackTrace();
            }
            System.out.println("出发");
        }).start();
    }
}
```



#### ReadWriteLock

读锁 -> 共享锁

写锁 -> 排它锁

```java
static void read(Lock lock) {
    try {
        lock.lock();
        Thread.sleep(1000);
        System.out.println("read over");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

static void write(Lock lock) {
    try {
        lock.lock();
        Thread.sleep(1000);
        System.out.println("write over");
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        lock.unlock();
    }
}

public static void main(String[] args) {
    ReentrantLock reentrantLock = new ReentrantLock();
    ReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    Lock readLock = readWriteLock.readLock();
    Lock writeLock = readWriteLock.writeLock();
    for (int i = 0; i < 10; i++) new Thread( () -> read(readLock)).start();
    for (int i = 0; i < 2; i++) new Thread( () -> write(writeLock)).start();
}
```



#### Semaphore

信号量

应用场景：限流，类似于车道和收费站（8个车道，2个收费站，一次只能过2辆车）

```java
public static void main(String[] args) {
//  Semaphore semaphore = new Semaphore(1);
    Semaphore semaphore = new Semaphore(1, true); // true指定为公平

    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T1 running");
            Thread.sleep(1000);
            System.out.println("T1 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
    new Thread( () -> {
        try {
            semaphore.acquire();
            System.out.println("T2 running");
            Thread.sleep(1000);
            System.out.println("T2 running");
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            semaphore.release();
        }
    }).start();
}
```



#### Exchanger

两个线程两两交换



#### LockSupport

park() -- 线程阻塞

unpark() -- 线程继续运行

unpark可以先于park调用，一旦先调用unpark，再调用park线程就不会阻塞了



#### Condition

Lock.newCondition

await/signal/signalAll

类比wait/notify/notifyAll

本质就是等待队列



```
wait/notify/notifyAll
await/signal/signalAll
park/unpark
归纳整理

LockSupport
Condition
生产者消费者题Condition版
AQS原理
```





## ThreadLocal

每个线程对象（Thread）内部会维护一个map，key是ThreadLocal对象（this），value是set进去的值

用于spring声明式事务



## 强软弱虚

软引用：内存不够时会回收掉软引用，做缓存用

弱引用：只要遭遇GC就会被回收，用在容器里（ThreadLocal -> WeakHashMap）

只要指向他的强引用消失了他就该被回收

虚引用：虚引用指向堆外内存，当虚引用被回收时，会放进指定的队列中，可以通过监听队列中的引用来回收堆外内存（非JVM管）的对象，操作堆外内存才用得到，比如写Netty和JVM



## 锁分类

乐观锁：CAS

悲观锁：Synchronized

自旋锁

读写锁

分段锁：LongAdder、ConrrentHashMap







