#### 缓存和DB双写不一致

- 先删缓存，再更新DB，再写缓存，高并发会出问题
- 将读写请求都路由到JVM的内存队列中
- 可对内存队列汇总的读请求进行去重，防止多次从DB查出来然后更新缓存

该方案存在的问题：

- 读请求长时阻塞：若写请求执行过慢，导致后面积压过多的读请求，读请求长时间阻塞，可以给读请求设置过期时间，过期前一直读缓存，过期了都读不到就直接查DB `读请求在内存队列中排在写请求后面，当写请求没执行完，那怎么对他后面的读请求进行这些操作呢，这里不理解`

  `读请求需要直接返回数据的，放内存队列不就异步了吗还怎么返回数据？`

- 读请求并发量过高：要严格测算出一个写请求会导致多少读请求hang住，估算出写读请求比例，最多不能超过1 : 3

- 多服务实例部署的请求路由：读写请求都路由到同一个机器上的同一个内存队列，不然还是有问题

  这么干又会导致热点数据的路由请求倾斜，在读写请求特别高时全部打到一台机器的相同队里去

  如果更新频率不大，这个问题影响也并不大

**详细在ryredis34**