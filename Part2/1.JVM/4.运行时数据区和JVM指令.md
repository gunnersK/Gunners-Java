 ## 运行时数据区

<img src=".\pic\Java运行时数据区.png" style="zoom:67%; float:left"/>



#### PC（线程私有）

程序计数器，记录目前执行到哪个字节码指令

每个线程有一个，为了线程切换用（线程切换回来知道刚才走到哪了）



#### JVM Stacks（线程私有）

JVM栈，执行Java方法，每个方法对应一个栈帧

**Frame**（栈帧）

- Local Variable Table  局部变量表 

  理解为存放局部变量的槽位，按顺序保存this变量、形参、方法体中的局部变量

  非static方法第0位是this，指向调用他的对象，第1位才从第一个形参开始

  static方法第0位就是第一个形参

- Operand Stack  操作数栈

  执行指令时将各种变量、常量压栈出栈，对其进行计算，结合下面的指令理解

- Dynamic Linking  

  指向运行时常量池的符号链接，指向方法名、方法类型等信息，如果没解析就动态解析，解析了就直接拿来使用

  比如a()方法调用b()方法，link就是在a()方法里面去常量池找b()方法的过程

  https://blog.csdn.net/qq_41813060/article/details/88379473

  JVMS 2.6.3

  ```
  不理解
  ```

- Return Address

  a()方法调用b()方法，存放b()方法执行完的返回值，以及b()方法执行完应该回到哪个地址继续执行

  

#### Native Method Stacks（线程私有）

本地方法栈，执行C/Cpp方法的，一般人为干涉不了



#### Direct Memory

直接内存，JVM直接访问内核内存，提高IO效率

老的IO，接收到网络数据先放到内核空间，再从内核空间复制到JVM，效率低

NIO，JVM直接访问内核空间的内存，实现**零拷贝**

这块不归JVM管，归OS管，写网络程序用的多



#### Method Area

方法区是一个逻辑概念，永久区和元空间是不同版本的方法区实现

- Perm Space（<1.8）

  字符串常量位于这里

  FGC不会清理

  启动时指定大小，不能变

- Meta Space（>=1.8 ）

  字符串常量位于堆

  会触发FGC清理

  若不设定大小，最大就是物理内存

所以一定要设置元空间JVM参数，如果给得小，在<1.8可能会产生方法区OOM，>=1.8可能会频繁FullGC



#### Run-Time Constant Pool

class文件中的常量池运行时放在这里

```
结合类文件结构的常量池理解
```







## JVM常见指令

<clinit\>：类构造器方法（有静态成员才会生成）

<init\>：类构造方法

_store：写操作

_load：读操作（操作数栈入栈）

invoke_XXX：方法调用指令

- InvokeVirtual：指令自带多态，对象引用从操作数栈弹出，用他执行InvokeVirtual指令的某个方法，他属于哪个对象就调用哪个对象的方法

- InvokeSpecial：可以直接定位、没有多态的方法（private、构造方法）

- InvokeInteface 调用接口变量的方法，如：List list  = new ArrayList(); list.add();   

- 类中每有一个lambda表达式就会生成一个内部类，如果死循环生成lambda表达式，1.8之前会导致方法区OOM（方法区不GC），1.8及之后会频繁FGC

  `看看八大原子指令`

指令前的序号有的不连续，因为有的指令占多个字节

调用方法的返回值放在本栈帧的栈顶```是栈帧还是操作数栈的栈顶，没明白```



#### case1

```java
void test(){
    int i = 8;
    i = i++;
    System.out.println(i);  //输出i是8
}
```

```
0 bipush 8
2 istore_1
3 iload_1
4 iinc 1 by 1
7 istore_1
8 return
```

>0 常量8入栈
>
>2 8出栈，写（store）给局部变量表第1位变量i
>
>3 变量i入栈
>
>4 变量i出栈，自增1
>
>7 变量i重新赋值给局部变量表第1位变量i（即重新赋值给自己）

 

```java
void test(){
    int i = 8;
    i = ++i;
    System.out.println(i);  //输出i是9
}
```

```
0 bipush 8
2 istore_1
3 iinc 1 by 1
6 iload_1
7 istore_1
8 return
```

> 0 常量8入栈
>
> 2 8出栈，写（store）给局部变量表第1位变量i
>
> 3 变量i自增1
>
> 4 变量i入栈
>
> 7 变量i出栈重新赋值给局部变量表第1位变量i（即重新赋值给自己）



#### case2

<img src=".\pic\方法调用字节码分析.png" style="zoom:;" />

> 左一：
>
> 0 开辟内存空间，把内存引用压入操作数栈（该指令占多个字节，故第二条指令从3开始）
>
> 3 将指令0压入操作数栈的引用复制一份（此时操作数栈有俩对象应用）
>
> 4 出栈一个引用，调用Hello_03的构造方法，初始化实例变量（此时操作数栈只剩一个引用）
>
> 7 出栈剩下那个引用，写（store）给局部变量表第1位的变量h（astore_1，后面那个1代表局部变量表第1位）
>
> 8 将局部变量表第1位的变量h读出来（load）压栈
>
> 9 h出栈，调用m1()方法
>
> 12 返回
>
> ---
>
> 中间：
>
> 9 h出栈，调用m1()方法，将返回值压入main方法栈帧的栈顶```是栈帧还是操作数栈的栈顶，没明白```
>
> 12 main方法的栈帧将刚才调用m1()方法保存在栈顶的返回值弹出（尽管没有用到）
>
> ---
>
> 右一：
>
> 12 将m1()方法的返回值出栈，写给局部变量表第2位i



#### case3（递归）

<img src=".\pic\递归方法字节码分析.png" style="zoom: 50%; float: left;" />

>0 局部变量表第1位变量n压栈
>
>1 常量1压栈
>
>2 俩元素出栈，判断两个数是否不相等，是就跳转到序号7行
>
>5 常量1压栈
>
>6 返回
>
>7 局部变量表第1位变量n压栈
>
>8 局部变量表第0位变量this压栈
>
>9 局部变量表第1位变量n压栈
>
>10 常量1压栈
>
>11 栈顶两个数出栈相减（此时栈顶元素是this变量）
>
>12 栈顶this变量出栈（此时栈中仅剩局部变量表第1位变量n），调用m()方法，返回值入栈
>
>15 m()方法的返回值和栈底变量n相乘



