## JVM优化思路

分析业务请求压力

查看机器内存大小分配

GC情况

#### Young/Old区优化

ry25-26 好好理解吸收

- 预估内存使用模型，高峰期系统运行压力
- 合理调整Survivor区，尽量不要触发动态年龄判断或分配担保进Old区
- 根据YGC频率，合理降低对象进入Old区的年龄，尽快让长期存活的对象进入Old区，如@Service、@Controller的业务系统逻辑组件



#### JVM优化是优化什么

JVM性能问题就是内存分配、参数设置不合理，导致对象频繁进入老年代，触发Old区GC，导致系统频繁卡顿

优化就是优化这个，减少GC对系统的影响

**调优原则：**根据系统的实际内存占用情况，合理分配内存比例，不要套用固定的模板



#### 大内存机器GC选择

大内存机器使用普通的收集器会导致STW时间过长，一般使用G1，自定义期望停顿时间，这会导致YGC频繁，而YGC频率高一些对系统影响并不会很大



#### 堆内存大小

xmn -- 新生代大小

xms -- 最小堆内存

xmx -- 最大堆内存

一般xms和xmx设置一样大



#### 永久代大小

一般设置几百M

溢出情况：



#### 栈内存大小

一般设置0.5-1M

溢出情况：



#### 预估内存压力

学会合理预估内存压力，选择合适的机器配置

根据一个业务场景，预估高峰期有多少对象、一个对象多大、会存活多久

再将这个场景扩展开来，将内存占用扩大10-20倍

拆分新生代老年代大小，确定机器内存

**画出业务流程图**再分析

上线系统前，要先预估系统的JVM内存、CPU负载、网络带宽、磁盘带宽/空间、关联数据库和中间件的压力

对JVM进行预估性优化、以及进行压测优化



#### 内存过小带来的问题

在请求高峰时，会快速生成很多对象，新生代占用急剧增加

由于压力骤增，导致系统性能下降，会有一部分请求要花费很长时间才处理完，生成一些长期存活对象

这时如果再往新生代分配对象，就会触发Minor GC，但是那些长期存活对象还在

然后新生代很快被填满，再次触发Minor GC，多次之后，那些对象就会被转移到老年代

之后慢请求处理完，在老年代中的对象就成了垃圾，而且老年代被占满的频率很快

频繁重复这个过程，就会频繁触发老年代GC

老年代GC速度很慢，极大影响系统性能







## 监控命令

#### jinfo

打印系统、JVM配置信息



#### jstack

打印线程栈信息



#### jstat

jstat -gc PID

##### 各参数含义

S0C -- S0区大小

S1C -- S1区大小

S0U -- S0区当前对象大小

S1U -- S1区当前对象大小

EC -- Eden区大小

EU -- Eden区当前对象大小

OC -- Old区大小

OU -- Old区当前对象大小

MC -- Method区大小

MU -- Method区当前对象大小

YGC -- YGC总次数

YGCT -- YGC总耗时

FGC -- FGC总次数

FGCT -- FGC总耗时

GCT -- 所有GC总耗时

##### 新生代对象增长速度

jstat -gc PID 1000 10

连续打印10次，每次间隔1000ms

##### YGC触发频率

根据Young区对象增长速度和Young区空间推测

##### YGC平均耗时

YGC总时间 / YGC总次数

##### YGC后存活对象和进入Old区的对象

统计每次YGC之后S1区和Old区新增的对象

##### FGC触发频率

根据Old区对象增长速度和Old区空间推测

##### FGC平均耗时

FGC总时间 / FGC总次数



> 根据以上几个参数去进行合理优化



#### jmap

生成堆转储文件，打印对象内存占用情况







## AdaptiveSizePolicy

JDK1.8默认使用PS+PO垃圾回收器组合（UseParallelGC），默认启动了-XX:+UseAdaptiveSizePolicy参数

根据STW时间、应用吞吐量，对Eden、S0、S1区进行自动扩缩容

但会引发GC问题：

如果Survivor被缩小时，有YGC后存活对象直接进入Old区的风险

建议关闭-XX:-UseAdaptiveSizePolicy

https://www.jianshu.com/p/7414fd6862c5

https://blog.csdn.net/u014263388/article/details/105617350







## JVM优化案例

- Survivor区太小导致对象频繁进入Old区，频繁触发FGC
- 使用反射，导致加载过多类使方法区满了，触发FGC
- 查DB不带where条件导致大对象直接进入Old，频发触发FGC
- System.gc()导致频繁FGC，-XX:+DisableExplicitGC参数禁止显示触发GC
- 使用JVM本地缓存导致缓存对象越来越多，最终造成内存泄露，使用缓存框架（如ehcache）即可







## MAT

若dump文件太大，需要对MAT做调整最大堆内存，在MemoryAnalyzer.ini文件中，-Xmx默认1024